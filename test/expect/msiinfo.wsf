<?xml version="1.0" encoding="utf-8" ?>
<job>
<object id="fso" progid="Scripting.FileSystemObject"/>
<object id="installer" progid="WindowsInstaller.Installer"/>
<script language="JScript"><![CDATA[
"use strict";
function Symbol(description) {
    var symbols = this.Symbol.symbols;
    var id = "Symbol@@" + description + "@@" + new Date().getTime() + "@@" + Math.random();
    symbols[id] = true;
    return {
        toString: function () {
            return id;
        },
        valueOf: function () {
            return description || '';
        }
    };
}
(function (Symbol) {
})(Symbol || (Symbol = {}));
(function () {
    var symbols = (this.Symbol.symbols = {});
    var registered = {};
    var keys = {};
    this.Symbol.isSymbol = function (symbol) { return !!symbols[symbol.toString()]; };
    this.Symbol["for"] = function (key) {
        var existing = registered[key];
        if (existing) {
            return existing;
        }
        var sym = Symbol(key);
        registered[key] = sym;
        keys[sym.toString()] = key;
        return sym;
    };
    this.Symbol.keyFor = function (sym) { return keys[sym.toString()]; };
})();
(function () {
    this.Symbol.iterator = Symbol('iterator');
    this.Symbol.iterator = Symbol('split');
    function polyfill_iterator(o) {
        var i = 0;
        return {
            next: function () {
                return i < o.length ? { value: o[i++] } : { done: true };
            }
        };
    }
    this.Array.prototype[Symbol.iterator] =
        this.Array.prototype[Symbol.iterator] ||
            function Array_iterator() {
                return polyfill_iterator(this);
            };
    this.String.prototype[Symbol.iterator] =
        this.String.prototype[Symbol.iterator] ||
            function String_iterator() {
                return polyfill_iterator(this);
            };
    if (typeof this.TypedArray === 'function') {
        this.TypedArray.prototype[Symbol.iterator] =
            this.TypedArray.prototype[Symbol.iterator] ||
                function TypedArray_iterator() {
                    return polyfill_iterator(this);
                };
    }
    if (typeof this.Map === 'function') {
        this.Map.prototype[Symbol.iterator] =
            this.Map.prototype[Symbol.iterator] ||
                function Map_iterator() {
                    return polyfill_iterator(this.entries());
                };
    }
    if (typeof this.Set === 'function') {
        this.Set.prototype[Symbol.iterator] =
            this.Set.prototype[Symbol.iterator] ||
                function Set_iterator() {
                    return polyfill_iterator(this.values());
                };
    }
})();
(function () {
    Date.prototype.toISOString =
        Date.prototype.toISOString ||
            function toISOString() {
                return (this.getUTCFullYear() +
                    '-' +
                    ('' + (this.getUTCMonth() + 1)).padStart(2, '0') +
                    '-' +
                    ('' + this.getUTCDate()).padStart(2, '0') +
                    'T' +
                    ('' + this.getUTCHours()).padStart(2, '0') +
                    ':' +
                    ('' + this.getUTCMinutes()).padStart(2, '0') +
                    ':' +
                    ('' + this.getUTCSeconds()).padStart(2, '0') +
                    '.' +
                    ('' + this.getUTCMilliseconds()).padStart(3, '0') +
                    'Z');
            };
    Date.now =
        Date.now ||
            function now() {
                return new Date().getTime();
            };
})();
(function () {
    String.prototype.repeat =
        String.prototype.repeat ||
            function repeat(count) {
                if (count < 0) {
                    throw new Error('repeat count must be non-negative');
                }
                if (count === Infinity) {
                    throw new Error('repeat count must be less than infinity');
                }
                if (this.length === 0) {
                    if (count < 1) {
                        return '';
                    }
                    throw new Error('empty string');
                }
                var r = '';
                while (count-- > 0) {
                    r += this;
                }
                return r;
            };
    var originalSubstr = String.prototype.substr;
    String.prototype.substr = function substr(start, length) {
        if (start < 0) {
            start += this.length;
        }
        length =
            length !== undefined
                ? length < 0
                    ? length + this.length - start
                    : length
                : this.length - start;
        return originalSubstr.call(this, start, length);
    };
    String.prototype.padStart =
        String.prototype.padStart ||
            function padStart(length, paddings) {
                var count = length - this.length;
                if (count <= 0) {
                    return this;
                }
                paddings = paddings || ' ';
                return (paddings
                    .repeat((count + paddings.length - 1) / paddings.length)
                    .substr(0, count) + this);
            };
    String.prototype.padEnd =
        String.prototype.padEnd ||
            function padEnd(length, paddings) {
                var count = length - this.length;
                if (count <= 0) {
                    return this;
                }
                paddings = paddings || ' ';
                return (this +
                    paddings
                        .repeat((count + paddings.length - 1) / paddings.length)
                        .substr(0, count));
            };
    String.prototype.startsWith =
        String.prototype.startsWith ||
            function startsWith(searchString, position) {
                position = position !== undefined ? position : 0;
                return (this.length - position >= searchString.length &&
                    this.lastIndexOf(searchString, position) === position);
            };
    String.prototype.endsWith =
        String.prototype.endsWith ||
            function endsWith(searchString, position) {
                position =
                    (position !== undefined ? position : this.length) - searchString.length;
                return position >= 0 && this.indexOf(searchString, position) === position;
            };
    String.prototype.trim =
        String.prototype.trim ||
            function trim() {
                var match = /(?:\S(?:.*\S)?)(?=\s*$)/.exec(this);
                return (match && match[0]) || '';
            };
    String.prototype.includes =
        String.prototype.includes ||
            function includes(searchString, position) {
                if (typeof position !== 'number') {
                    position = 0;
                }
                return (position + searchString.length <= this.length &&
                    this.indexOf(searchString, position) >= 0);
            };
    String.prototype.split = function split(separator, limit) {
        var str = '' + this;
        if (separator &&
            typeof separator !== 'string' &&
            !(separator instanceof RegExp) &&
            typeof separator[Symbol.split] === 'function') {
            return separator[Symbol.split](str, limit);
        }
        var index = 0;
        var result = [];
        if (separator instanceof RegExp) {
            var prev = 0;
            var re = separator.global
                ? separator
                : new RegExp(separator.source, "g" + (separator.multiline ? 'm' : '') + (separator.ignoreCase ? 'i' : ''));
            while (true) {
                re.lastIndex = index;
                var match = re.exec(str);
                if (!match) {
                    break;
                }
                if (match[0].length) {
                    var next = match.index;
                    var splitted = str.substr(prev, next - prev);
                    result.push(splitted);
                    prev = index = next + match[0].length;
                }
                else {
                    if (index === prev) {
                        index = prev + 1;
                        if (index >= str.length) {
                            return result;
                        }
                        continue;
                    }
                    if (index >= str.length) {
                        break;
                    }
                    var next = index;
                    var splitted = str.substr(prev, next - prev);
                    prev = next;
                    result.push(splitted);
                    ++index;
                }
                for (var i = 1; i < match.length; ++i) {
                    result.push(match[i]);
                }
            }
            result.push(str.substr(prev));
            return result;
        }
        if (!separator) {
            return Array(str.length)
                .fill(0)
                .map(function (_, i) { return str.substr(i, 1); });
        }
        separator = '' + separator;
        while (index < str.length) {
            var next = str.indexOf(separator, index);
            if (next < 0) {
                break;
            }
            result.push(str.substr(index, next - index));
            index = next + separator.length;
        }
        result.push(str.substr(index));
        return result;
    };
})();
(function () {
    this.console = this.console || {};
    function output(stream, messages) {
        stream.WriteLine("[" + new Date().toLocaleTimeString() + "] " + Array.from(messages)
            .map(function (m) { return (m === undefined ? 'undefined' : m === null ? 'null' : m); })
            .join(' '));
    }
    this.console.log =
        this.console.log ||
            function log() {
                output(WScript.StdOut, arguments);
            };
    this.console.error =
        this.console.error ||
            function error() {
                output(WScript.StdErr, arguments);
            };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
(function () {
    Array.isArray =
        Array.isArray ||
            function isArray(obj) {
                return Object.prototype.toString.call(obj) === '[object Array]';
            };
    Array.of =
        Array.of ||
            function of() {
                return Array.prototype.slice.call(arguments);
            };
    Array.from =
        Array.from ||
            function from(arrayLike, mapFn, thisArg) {
                if (typeof mapFn !== 'function' &&
                    Object.prototype.toString.call(mapFn) !== '[object Function]') {
                    mapFn = function (e) { return e; };
                }
                var array;
                if (Array.isArray(arrayLike)) {
                    array = arrayLike.map(mapFn, thisArg);
                }
                else if (typeof arrayLike === 'object' &&
                    (typeof arrayLike.Item === 'function' ||
                        typeof arrayLike.item === 'function')) {
                    array = new Array();
                    var i = 0;
                    for (var e = new Enumerator(arrayLike); !e.atEnd(); e.moveNext()) {
                        array.push(mapFn.call(thisArg, e.item(), i++));
                    }
                }
                else {
                    var len = +arrayLike.length || 0;
                    array = new Array(len);
                    for (var i = 0; i < len; ++i) {
                        array[i] = mapFn.call(thisArg, arrayLike[i], i);
                    }
                }
                return array;
            };
    Array.prototype.some =
        Array.prototype.some ||
            function some(callback, thisObj) {
                for (var i = 0; i < this.length; ++i) {
                    if (!(i in this)) {
                        continue;
                    }
                    if (callback.call(thisObj, this[i], i, this)) {
                        return true;
                    }
                }
                return false;
            };
    Array.prototype.every =
        Array.prototype.every ||
            function every(callback, thisObj) {
                return !this.some(function (e, i, a) { return !callback.call(thisObj, e, i, a); });
            };
    Array.prototype.reduce =
        Array.prototype.reduce ||
            function reduce(callback, initialValue) {
                var index = 0;
                var result = 1 < arguments.length ? initialValue : this[index++];
                for (; index < this.length; ++index) {
                    if (!(index in this)) {
                        continue;
                    }
                    result = callback.call(null, result, this[index], index, this);
                }
                return result;
            };
    Array.prototype.reduceRight =
        Array.prototype.reduceRight ||
            function reduceRight(callback, initialValue) {
                var index = this.length;
                var result = 1 < arguments.length ? initialValue : this[--index];
                while (index-- > 0) {
                    if (!(index in this)) {
                        continue;
                    }
                    result = callback.call(null, result, this[index], index, this);
                }
                return result;
            };
    Array.prototype.forEach =
        Array.prototype.forEach ||
            function forEach(callback, thisObj) {
                this.reduce(function (r, e, i, a) { return callback.call(thisObj, e, i, a) && false; }, false);
            };
    Array.prototype.filter =
        Array.prototype.filter ||
            function filter(callback, thisObj) {
                return this.reduce(function (r, e, i, a) {
                    if (callback.call(thisObj, e, i, a)) {
                        r.push(e);
                    }
                    return r;
                }, []);
            };
    Array.prototype.map =
        Array.prototype.map ||
            function map(callback, thisObj) {
                return this.reduce(function (r, e, i, a) {
                    r[i] = callback.call(thisObj, e, i, a);
                    return r;
                }, []);
            };
    var adjustIndex = function (args, index, length, defaultValue) {
        var value = args.length > index ? +args[index] : NaN;
        if (isNaN(value)) {
            if (defaultValue === undefined) {
                throw new Error('arguments[' + index + '] required');
            }
            value = defaultValue;
        }
        if (value < 0) {
            value += length;
            if (value < 0) {
                value = 0;
            }
        }
        return value;
    };
    Array.prototype.copyWithin =
        Array.prototype.copyWithin ||
            function copyWithin() {
                var target = adjustIndex(arguments, 1, this.length);
                var start = adjustIndex(arguments, 1, this.length, 0);
                var end = adjustIndex(arguments, 2, this.length, this.length);
                var targetEnd = Math.min(target + (end - start), this.length);
                if (target < start) {
                    for (var i = target; i < targetEnd; ++i) {
                        if (!(i in this)) {
                            continue;
                        }
                        this[i] = this[start + i - target];
                    }
                }
                else {
                    for (var i = targetEnd; --i >= target;) {
                        if (!(i in this)) {
                            continue;
                        }
                        this[i] = this[start + i - target];
                    }
                }
                return this;
            };
    Array.prototype.fill =
        Array.prototype.fill ||
            function fill(value) {
                var start = adjustIndex(arguments, 1, this.length, 0);
                var end = adjustIndex(arguments, 2, this.length, this.length);
                for (var i = start; i < end; ++i) {
                    this[i] = value;
                }
                return this;
            };
    Array.prototype.find =
        Array.prototype.find ||
            function find(pred, thisArg) {
                var result;
                this.some(function (e, i, a) { return pred.call(thisArg, e, i, a) && ((result = e), true); });
                return result;
            };
    Array.prototype.findIndex =
        Array.prototype.findIndex ||
            function findIndex(pred, thisArg) {
                var result = -1;
                this.some(function (e, i, a) { return pred.call(thisArg, e, i, a) && ((result = i), true); });
                return result;
            };
    Array.prototype.includes =
        Array.prototype.includes ||
            function includes(searchElement) {
                var e_1, _a;
                try {
                    for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var e = _c.value;
                        if (e === searchElement) {
                            return true;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return false;
            };
    Array.prototype.indexOf =
        Array.prototype.lastIndexOf ||
            function indexOf(searchElement) {
                for (var index = adjustIndex(arguments, 1, this.length, 0); index < this.length; ++index) {
                    if (this[index] === searchElement) {
                        return index;
                    }
                }
                return -1;
            };
    Array.prototype.lastIndexOf =
        Array.prototype.lastIndexOf ||
            function lastIndexOf(searchElement) {
                for (var index = adjustIndex(arguments, 1, this.length, this.length - 1); index >= 0; --index) {
                    if (this[index] === searchElement) {
                        return index;
                    }
                }
                return -1;
            };
    Array.prototype.entries =
        Array.prototype.entries ||
            function entries() {
                return this.map(function (value, index) { return [index, value]; });
            };
    Array.prototype.keys =
        Array.prototype.keys ||
            function keys() {
                return this.map(function (_, index) { return index; });
            };
})();
(function () {
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor',
    ];
    Object.keys =
        Object.keys ||
            function keys(obj) {
                var e_2, _a;
                if (typeof obj !== 'function' &&
                    (typeof obj !== 'object' || obj === null)) {
                    throw new TypeError('Object.keys called on non-object');
                }
                var result = [];
                for (var prop in obj) {
                    if (Symbol.isSymbol(prop)) {
                        continue;
                    }
                    if (!hasOwnProperty.call(obj, prop)) {
                        continue;
                    }
                    result.push(prop);
                }
                if (hasDontEnumBug) {
                    try {
                        for (var dontEnums_1 = __values(dontEnums), dontEnums_1_1 = dontEnums_1.next(); !dontEnums_1_1.done; dontEnums_1_1 = dontEnums_1.next()) {
                            var name = dontEnums_1_1.value;
                            if (!hasOwnProperty.call(obj, name)) {
                                continue;
                            }
                            result.push(name);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (dontEnums_1_1 && !dontEnums_1_1.done && (_a = dontEnums_1["return"])) _a.call(dontEnums_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                return result;
            };
    Object.entries =
        Object.entries ||
            function entries(obj) {
                return Object.keys(obj).map(function (key) { return [key, obj[key]]; });
            };
    Object.values =
        Object.values ||
            function values(obj) {
                return Object.keys(obj).map(function (key) { return obj[key]; });
            };
    Object.create =
        Object.create ||
            function create(proto, propertiesObject) {
                if (typeof proto !== 'object' && typeof proto !== 'function') {
                    throw new TypeError('Object prototype may only be an Object: ' + proto);
                }
                if (proto === null) {
                    throw new Error("This Object.create is a shim and doesn't support 'null' as the first argument.");
                }
                if (propertiesObject !== undefined) {
                    throw new Error("This Object.create is a shim and doesn't support a second argument.");
                }
                var F = function () { };
                F.prototype = proto;
                return new F();
            };
    Object.assign =
        Object.assign ||
            function assign(target) {
                var e_3, _a, e_4, _b;
                var sources = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    sources[_i - 1] = arguments[_i];
                }
                if (target == null) {
                    throw new TypeError('Cannot convert null or undefined to object');
                }
                var to = new Object(target);
                try {
                    for (var sources_1 = __values(sources), sources_1_1 = sources_1.next(); !sources_1_1.done; sources_1_1 = sources_1.next()) {
                        var source = sources_1_1.value;
                        try {
                            for (var _c = (e_4 = void 0, __values(Object.keys(source))), _d = _c.next(); !_d.done; _d = _c.next()) {
                                var name = _d.value;
                                to[name] = source[name];
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_b = _c["return"])) _b.call(_c);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (sources_1_1 && !sources_1_1.done && (_a = sources_1["return"])) _a.call(sources_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return to;
            };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
(function () {
    var ENQUOTE = {
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"': '\\"',
        '/': '\\/',
        '\\': '\\\\'
    };
    var DEQUOTE = Object.keys(ENQUOTE).reduce(function (r, ch) { return ((r[ENQUOTE[ch].charAt(1)] = ch), r); }, {});
    var ENQUOTE_RE = new RegExp("[" + Object.keys(ENQUOTE)
        .map(function (ch) { return (ch === '\\' ? '\\\\' : ch); })
        .join('') + "\0-\u001F]", 'g');
    var DEQUOTE_RE = new RegExp("\\\\(?:([" + Object.keys(DEQUOTE)
        .map(function (ch) { return (ch === '\\' ? '\\\\' : ch); })
        .join('') + "])|u([0-9A-Fa-f]{4}))", 'g');
    var ACCEPT_TYPES = {
        boolean: true,
        number: true,
        object: true,
        string: true,
        undefined: true
    };
    this.JSON = this.JSON || {};
    function enquote(str) {
        return "\"" + str.replace(ENQUOTE_RE, function (ch) {
            return ENQUOTE[ch] ||
                '\\u' +
                    ch
                        .charCodeAt(0)
                        .toString(16)
                        .padStart(4, '0');
        }) + "\"";
    }
    function dequote(quoted) {
        return quoted
            .substr(1, -1)
            .replace(DEQUOTE_RE, function (_, ch, hex) {
            return hex ? String.fromCharCode(parseInt(hex, 16)) : DEQUOTE[ch];
        });
    }
    var cache = {};
    var Parser = (function () {
        function Parser(str) {
            this.str = str;
            this.index = 0;
        }
        Parser.prototype.parse = function (reviewer) {
            var value = this.parseValue();
            this.skipWS();
            if (this.isLeft()) {
                this.failedParsing();
            }
            if (!reviewer) {
                return value;
            }
            return (function recursive(key, subvalue) {
                var e_5, _a;
                if (subvalue && typeof subvalue === 'object') {
                    try {
                        for (var _b = __values(Object.entries(subvalue)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var _d = __read(_c.value, 2), k = _d[0], v = _d[1];
                            subvalue[k] = recursive(k, v);
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                }
                return reviewer(key, subvalue);
            })('', value);
        };
        Parser.prototype.stickyMatch = function (pattern) {
            var re = cache[pattern] ||
                (cache[pattern] = new RegExp("(?:" + pattern + ")|(?=([\\s\\S]))", 'g'));
            re.lastIndex = this.index;
            var match = re.exec(this.str);
            if (!match || match[match.length - 1]) {
                return undefined;
            }
            this.index += match[0].length;
            return match;
        };
        Parser.prototype.failedParsing = function () {
            if (!this.isLeft()) {
                throw new Error("Unexpected the end of string");
            }
            var re = /[^\r\n]*(?:\r?\n|\r|$)/g;
            var _a = __read([0, 0], 2), line = _a[0], bol = _a[1];
            while (true) {
                var match = re.exec(this.str);
                if (!match) {
                    break;
                }
                var eol = match.index + match[0].length;
                if (eol >= this.index) {
                    break;
                }
                ++line;
                bol = eol;
            }
            var column = this.index - bol;
            throw new Error("unexpected: " + this.str.substr(this.index, 10) + " at line: " + line + ", column: " + column);
        };
        Parser.prototype.skipWS = function () {
            this.stickyMatch("\\s+");
        };
        Parser.prototype.scanOne = function (candidates, nothrow) {
            this.skipWS();
            if (!this.isLeft()) {
                return this.failedParsing();
            }
            var ch = this.str.charAt(this.index);
            if (candidates.indexOf(ch) < 0) {
                if (nothrow) {
                    return undefined;
                }
                return this.failedParsing();
            }
            ++this.index;
            return ch;
        };
        Parser.prototype.parseWord = function (pattern, value) {
            this.skipWS();
            return this.stickyMatch(pattern) ? value : this.failedParsing();
        };
        Parser.prototype.parseNumber = function () {
            this.skipWS();
            var match = this.stickyMatch("-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[Ee][-+]?\\d+)?\\b");
            return match ? +match[0] : this.failedParsing();
        };
        Parser.prototype.parseString = function () {
            this.skipWS();
            var match = this.stickyMatch("\"[^\\\\\"]*(?:\\\\.[^\\\\\"]*)*\"");
            return match ? dequote(match[0]) : this.failedParsing();
        };
        Parser.prototype.parseSequence = function (terminater, initialValue, continuousProc) {
            ++this.index;
            var value = initialValue;
            if (!this.scanOne(terminater, true)) {
                var termsep = terminater + ',';
                do {
                    continuousProc(value);
                } while (this.scanOne(termsep) !== terminater);
            }
            return value;
        };
        Parser.prototype.parseValue = function () {
            var _this = this;
            this.skipWS();
            switch (this.str.charAt(this.index)) {
                case 'n':
                    return this.parseWord("null\\b", null);
                case 't':
                    return this.parseWord("true\\b", true);
                case 'f':
                    return this.parseWord("false\\b", false);
                case '-':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    return this.parseNumber();
                case '"':
                    return this.parseString();
                case '[':
                    return this.parseSequence(']', [], function (arr) {
                        arr.push(_this.parseValue());
                    });
                case '{':
                    return this.parseSequence('}', {}, function (obj) {
                        _this.skipWS();
                        var name = _this.parseString();
                        _this.scanOne(':');
                        obj[name] = _this.parseValue();
                    });
            }
            this.failedParsing();
        };
        Parser.prototype.isLeft = function () {
            return this.index < this.str.length;
        };
        return Parser;
    }());
    this.JSON.parse =
        this.JSON.parse ||
            function parse(str, reviewer) {
                return new Parser(str).parse(reviewer);
            };
    this.JSON.stringify =
        this.JSON.stringify ||
            function stringify(value, replacer, space) {
                var validKeys = Array.isArray(replacer) ? replacer : undefined;
                var p = typeof replacer === 'function' ? replacer : undefined;
                var indentUnit = typeof space === 'number'
                    ? ' '.repeat(space)
                    : typeof space === 'string'
                        ? space
                        : '';
                var indent = function (depth) {
                    return (indentUnit && '\n' + indentUnit.repeat(depth)) || '';
                };
                return (function sub(v, depth) {
                    switch (v) {
                        case undefined:
                        case null:
                            return 'null';
                        case true:
                            return 'true';
                        case false:
                            return 'false';
                    }
                    var handlers = {
                        number: function (n) { return (isNaN(n) ? 'null' : '' + n); },
                        string: function (s) { return enquote(s); },
                        object: function (o) {
                            if (typeof o.toJSON === 'function') {
                                var json = o.toJSON();
                                if (json !== o) {
                                    return sub(json, depth);
                                }
                            }
                            if (Array.isArray(o)) {
                                if (o.length === 0) {
                                    return '[]';
                                }
                                return ('[' +
                                    indent(depth + 1) +
                                    o
                                        .map(function (json, i) {
                                        return sub(p ? p('' + i, json) : json, depth + 1) ||
                                            'null';
                                    })
                                        .join(',' + indent(depth + 1)) +
                                    indent(depth) +
                                    ']');
                            }
                            var entries = Object.entries(o)
                                .filter(function (_a) {
                                var _b = __read(_a, 2), k = _b[0], sv = _b[1];
                                return ACCEPT_TYPES[typeof sv] &&
                                    (!validKeys || validKeys.includes(k));
                            })
                                .map(function (_a) {
                                var _b = __read(_a, 2), k = _b[0], sv = _b[1];
                                return [enquote(k), sub(p ? p(k, sv) : sv, depth + 1)];
                            })
                                .filter(function (_a) {
                                var _b = __read(_a, 2), sv = _b[1];
                                return !!sv;
                            })
                                .map(function (_a) {
                                var _b = __read(_a, 2), k = _b[0], sv = _b[1];
                                return k + ":" + (space ? ' ' : '') + sv;
                            });
                            if (entries.length === 0) {
                                return '{}';
                            }
                            return ('{' +
                                indent(depth + 1) +
                                entries.join(',' + indent(depth + 1)) +
                                indent(depth) +
                                '}');
                        }
                    };
                    var handler = handlers[typeof v];
                    return handler ? handler(v) : '';
                })(value, 0);
            };
})();

(function () {
    var registeredObjects = [];
    var handlers = [];

    var trigger = function (objectIndex, eventName, params) {
        var obj = registeredObjects[objectIndex];
        handlers[objectIndex][eventName].forEach(function (x) {
            x.call(obj, params);
        });
    };

    ActiveXObject.on = function (obj, eventName, parameterNames, handler) {
        if (Object.prototype.toString.call(parameterNames) !== '[object Array]') {
            //parameterNames is an optional argument
            handler = parameterNames;
            parameterNames = [];
        }

        var objectIndex = registeredObjects.indexOf(obj);
        if (objectIndex == -1) {
            registeredObjects.push(obj);
            objectIndex = registeredObjects.length - 1;
            handlers[objectIndex] = {};
        }
        if (handlers[objectIndex][eventName] === undefined) { //explicit check against undefined, because it might be an empty array
            var def = "function obj::" + eventName + " (" + parameterNames.join(', ') + ") {" +
                "var params = { " +
                parameterNames.map(function (x) {
                    return x + ':' + x;
                }).join(',') +
                " };" +
                "trigger( " + objectIndex + ", '" + eventName + "', params);" +
                parameterNames.map(function (x) {
                    return "if ( " + x + " !== params." + x + " ) " + x + " = params." + x + ";";
                }).join('\n') +
                "};";
            eval(def);
            handlers[objectIndex][eventName] = [];
        }
        handlers[objectIndex][eventName].push(handler);
    };

    ActiveXObject.off = function (obj, eventName, handler) {
        if (!obj) {
            registeredObjects.forEach(function (x) {
                ActiveXObject.off(x);
            });
            registeredObjects = [];
            return;
        }

        var objectIndex = registeredObjects.indexOf(obj);
        var handlersObject = handlers[objectIndex];
        if (!eventName) {
            Object.keys(handlersObject).forEach(function (x) {
                ActiveXObject.off(obj, x);
            });
            registeredObjects[objectIndex] = undefined;
            return;
        }

        if (!handler) {
            handlersObject[eventName] = [];
            return;
        }

        var handlerIndex = handlersObject[eventName].indexOf(handler);
        while (handlerIndex > -1) {
            handlersObject[eventName][handlerIndex] = undefined;
            handlerIndex = handlersObject[eventName].indexOf(handler);
        }
    };

    ActiveXObject.hasRegisteredObjects = function () {
        return registeredObjects.length > 0;
    };

    ActiveXObject.set = function (obj, propertyName, parameters, newValue) {
        /*@cc_on @*/
        /*@
        switch (parameters.length) {
            case 0:
                obj[propertyName] = newValue;
                return;
            case 1:
                obj[propertyName](parameters[0]) = newValue;
                return;
            case 2:
                obj[propertyName](parameters[0], parameters[1]) = newValue;
                return;
            case 3:
                obj[propertyName](parameters[0], parameters[1], parameters[2]) = newValue;
                return;
            default:
                break; // fallback to eval
        }
        @*/
        var parameterString = parameters.map(function (x, index) {
            return 'parameters[' + index + ']';
        }).join(', ');
        var callString = parameterString ? '(' + parameterString + ')' : "";
        eval('obj[propertyName]' + callString + ' = newValue');
    };
})();
(function () {
"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Iterables;
(function (Iterables) {
    /**
     * Iterables のメソッドをメンバに持つIterable。
     *
     * @class IterableEx
     * @implements {I<T>}
     * @template T
     */
    var IterableEx = /** @class */ (function () {
        function IterableEx(param) {
            this.i = typeof param === 'function' ? param() : param;
        }
        IterableEx.prototype[Symbol.iterator] = function () {
            return this.i[Symbol.iterator]();
        };
        IterableEx.prototype.forEach = function (callback) {
            forEach(this, callback);
        };
        IterableEx.prototype.some = function (callback) {
            return some(this, callback);
        };
        IterableEx.prototype.every = function (callback) {
            return every(this, callback);
        };
        IterableEx.prototype.filter = function (callback) {
            return filter(this, callback);
        };
        IterableEx.prototype.map = function (callback) {
            return map(this, callback);
        };
        IterableEx.prototype.reduce = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return reduce.apply(void 0, __spread([this], args));
        };
        IterableEx.prototype.join = function (sep) {
            return join(this, sep);
        };
        return IterableEx;
    }());
    /**
     * Iterableの返す各要素に対してコールバックを呼び出す。
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {(e: T, i: number, x: X) => any} callback 引数で指定したIterableの各要素を渡して呼び出すコールバックを指定する。
     */
    function forEach(x, callback) {
        var e_1, _a;
        var i = 0;
        try {
            for (var x_1 = __values(x), x_1_1 = x_1.next(); !x_1_1.done; x_1_1 = x_1.next()) {
                var e = x_1_1.value;
                callback(e, i++, x);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (x_1_1 && !x_1_1.done && (_a = x_1["return"])) _a.call(x_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    Iterables.forEach = forEach;
    /**
     * Iterableの返す各要素に対してコールバックを呼び出し、一つでもtruthyな値を返すものがあればtrueを返す。
     *
     * truthyな値を返す要素が見つかった時点で各要素へのコールバックの呼び出しを中断する。
     *
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {(e: T, i: number, x: X) => boolean} callback 引数で指定したIterableの各要素を渡して呼び出すコールバックを指定する。
     * @returns {boolean} Iterableの返す各要素に対してコールバックを呼び出し、一つでもtruthyな値を返すものがあればtrueを返す。いずれの要素もfalsyな値を返した場合はfalseを返す。
     */
    function some(x, callback) {
        var e_2, _a;
        var i = 0;
        try {
            for (var x_2 = __values(x), x_2_1 = x_2.next(); !x_2_1.done; x_2_1 = x_2.next()) {
                var e = x_2_1.value;
                if (callback(e, i++, x)) {
                    return true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (x_2_1 && !x_2_1.done && (_a = x_2["return"])) _a.call(x_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return false;
    }
    Iterables.some = some;
    /**
     * Iterableの返す各要素に対してコールバックを呼び出し、一つでもfalsyな値を返すものがあればfalseを返す。
     *
     * falsyな値を返す要素が見つかった時点で各要素へのコールバックの呼び出しを中断する。
     *
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {(e: T, i: number, x: X) => boolean} callback 引数で指定したIterableの各要素を渡して呼び出すコールバックを指定する。
     * @returns {boolean} Iterableの返す各要素に対してコールバックを呼び出し、一つでもfalsyな値を返すものがあればfalseを返す。いずれの要素もtruthyな値を返した場合はtrueを返す。
     */
    function every(x, callback) {
        var e_3, _a;
        var i = 0;
        try {
            for (var x_3 = __values(x), x_3_1 = x_3.next(); !x_3_1.done; x_3_1 = x_3.next()) {
                var e = x_3_1.value;
                if (!callback(e, i++, x)) {
                    return false;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (x_3_1 && !x_3_1.done && (_a = x_3["return"])) _a.call(x_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return true;
    }
    Iterables.every = every;
    function filter(x, callback) {
        return new IterableEx(function () {
            var i, x_4, x_4_1, e, e_4_1;
            var e_4, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        i = 0;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        x_4 = __values(x), x_4_1 = x_4.next();
                        _b.label = 2;
                    case 2:
                        if (!!x_4_1.done) return [3 /*break*/, 5];
                        e = x_4_1.value;
                        if (!callback(e, i++, x)) return [3 /*break*/, 4];
                        return [4 /*yield*/, e];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        x_4_1 = x_4.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_4_1 = _b.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (x_4_1 && !x_4_1.done && (_a = x_4["return"])) _a.call(x_4);
                        }
                        finally { if (e_4) throw e_4.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    }
    Iterables.filter = filter;
    /**
     * Iterableの返す各要素に対してコールバックを呼び出し、コールバックの返す値を要素とするIterableExを生成する。
     *
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @template S この関数が返すIterableExの要素の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {(e: T, i: number, x: X) => S} callback 引数で指定したIterableの各要素を渡して呼び出すコールバックを指定する。
     * @returns {IterableEx<T>} Iterableの返す各要素に対してコールバックを呼び出し、コールバックの返す値を要素とするIterableExを生成して返す。
     */
    function map(x, callback) {
        return new IterableEx(function () {
            var i, x_5, x_5_1, e, e_5_1;
            var e_5, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        i = 0;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        x_5 = __values(x), x_5_1 = x_5.next();
                        _b.label = 2;
                    case 2:
                        if (!!x_5_1.done) return [3 /*break*/, 5];
                        e = x_5_1.value;
                        return [4 /*yield*/, callback(e, i++, x)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        x_5_1 = x_5.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_5_1 = _b.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (x_5_1 && !x_5_1.done && (_a = x_5["return"])) _a.call(x_5);
                        }
                        finally { if (e_5) throw e_5.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    }
    Iterables.map = map;
    function reduce(x, callback, initialValue) {
        var _a, e_6, _b;
        var iterable = x;
        var initialIndex = 0;
        if (arguments.length <= 2) {
            var itr_1 = x[Symbol.iterator]();
            var ir = itr_1.next();
            if (ir.done) {
                throw new Error('Reduce of empty Iterable with no initial value');
            }
            initialIndex = 1;
            iterable = (_a = {},
                _a[Symbol.iterator] = function () {
                    return itr_1;
                },
                _a);
            initialValue = ir.value; // arguments.length <= 2 なら ir.value is S(=T)
        }
        var r = initialValue; // arguments.length > 2 なら initialValue is S(not null)
        var i = initialIndex;
        try {
            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                var e = iterable_1_1.value;
                r = callback(r, e, i++, x);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (iterable_1_1 && !iterable_1_1.done && (_b = iterable_1["return"])) _b.call(iterable_1);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return r;
    }
    Iterables.reduce = reduce;
    /**
     * Iterableの返す各要素を文字列に変換し、結合する。
     *
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {string} sep 結合する際に各要素間に挿入する文字列を指定する。
     * @returns {string} Iterableの返す各要素を文字列に変換し、結合した文字列を返す。
     */
    function join(x, sep) {
        return map(x, function (e) { return e.toString(); }).reduce(function (r, c) { return r + sep + c; });
    }
    Iterables.join = join;
    /**
     * 引数に指定した全てのIterableを結合したIterableExを生成する。
     *
     * @export
     * @template T 全引数の型を指定する。
     * @param {...T} generators Iterableの配列を指定する
     * @returns {Ex<T extends Array<I<infer R>> ? R : never>} 引数に指定した全てのIterableを結合したIterableExを生成して返す。
     */
    function concat() {
        var generators = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            generators[_i] = arguments[_i];
        }
        return new IterableEx(function () {
            var generators_1, generators_1_1, generator, e_7_1;
            var e_7, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, 6, 7]);
                        generators_1 = __values(generators), generators_1_1 = generators_1.next();
                        _b.label = 1;
                    case 1:
                        if (!!generators_1_1.done) return [3 /*break*/, 4];
                        generator = generators_1_1.value;
                        return [5 /*yield**/, __values(generator)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        generators_1_1 = generators_1.next();
                        return [3 /*break*/, 1];
                    case 4: return [3 /*break*/, 7];
                    case 5:
                        e_7_1 = _b.sent();
                        e_7 = { error: e_7_1 };
                        return [3 /*break*/, 7];
                    case 6:
                        try {
                            if (generators_1_1 && !generators_1_1.done && (_a = generators_1["return"])) _a.call(generators_1);
                        }
                        finally { if (e_7) throw e_7.error; }
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    }
    Iterables.concat = concat;
    function isIterable(collection) {
        return typeof collection[Symbol.iterator] === 'function';
    }
    function from(collection) {
        var _a;
        // もともとIterableExの場合はそのまま返す
        if (isIterableEx(collection)) {
            return collection;
        }
        return new IterableEx(
        // Iterableの場合はIterableExのコンストラクタに引数として渡す
        isIterable(collection)
            ? collection
            : // それ以外はEnumeratorを生成してみてコンストラクタに引数として渡す
             (_a = {},
                _a[Symbol.iterator] = function () {
                    var e = new Enumerator(collection);
                    return {
                        next: function () {
                            if (e.atEnd()) {
                                return { done: true };
                            }
                            var value = e.item();
                            e.moveNext();
                            return { done: false, value: value };
                        }
                    };
                },
                _a));
    }
    Iterables.from = from;
    function of() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return from(args);
    }
    Iterables.of = of;
    function max(itr) {
        return reduce(itr, function (mx, e) { return (mx < e ? e : mx); });
    }
    Iterables.max = max;
    function min(itr) {
        return reduce(itr, function (mn, e) { return (mn > e ? e : mn); });
    }
    Iterables.min = min;
    /**
     * IterableExかどうかを判別する
     * @export
     * @param {*} x IterableExかどうかを判別するオブジェクト
     * @returns {x is IterableEx<any>} gがIterableExであれば真を返す。
     */
    function isIterableEx(x) {
        return x && x instanceof IterableEx;
    }
})(Iterables || (Iterables = {}));
/// <reference types="activex-scripting" />
/// <reference types="iterables" />
var Scripting;
(function (Scripting) {
    var FileSystemObject;
    (function (FileSystemObject) {
        var Utils;
        (function (Utils) {
            function isFolder(f) {
                return 'Files' in f;
            }
            Utils.isFolder = isFolder;
            function isFile(f) {
                return !isFolder(f);
            }
            Utils.isFile = isFile;
            function sort(array) {
                return array.sort(function (a, b) {
                    var aa = a.Name.toUpperCase();
                    var bb = b.Name.toUpperCase();
                    return aa === bb ? 0 : aa < bb ? -1 : 1;
                });
            }
            function files(folder) {
                return sort(__spread(Iterables.from(folder.Files)));
            }
            Utils.files = files;
            function subFolders(folder) {
                return sort(__spread(Iterables.from(folder.SubFolders)));
            }
            Utils.subFolders = subFolders;
            function filesAndSubFolders(folder) {
                return sort(__spread(Iterables.concat(Iterables.from(folder.Files), Iterables.from(folder.SubFolders))));
            }
            Utils.filesAndSubFolders = filesAndSubFolders;
            function getItem(path) {
                if (fso.FileExists(path)) {
                    return fso.GetFile(path);
                }
                if (fso.FolderExists(path)) {
                    return fso.GetFolder(path);
                }
                return undefined;
            }
            Utils.getItem = getItem;
            function splitPath(path) {
                var splited = [];
                var match = /^(?:([A-Z]):|\\{2,}([^\\]+)\\+([^\\]+))?(\\+|$)?/i.exec(path);
                if (match) {
                    if (match[1]) {
                        if (!match[4]) {
                            throw new Error("ドライブ指定時には絶対パスで指定してください");
                        }
                        splited.push(match[1] + ":\\");
                    }
                    else if (match[2]) {
                        splited.push("\\\\" + match[2] + ":\\" + match[3] + "\\");
                    }
                    else if (match[4]) {
                        splited.push('\\');
                    }
                    if (match[0]) {
                        path = path.substr(match[0].length);
                    }
                }
                if (!path) {
                    return splited;
                }
                return splited.concat(path.split(/\\+/));
            }
            Utils.splitPath = splitPath;
            function relativePath(path, base) {
                var absolute = fso.GetAbsolutePathName(path);
                var pathSplitted = splitPath(absolute);
                var aa = fso.GetAbsolutePathName(base || '.');
                var baseSplitted = splitPath(aa);
                var limit = Math.min(pathSplitted.length, baseSplitted.length);
                var matchedLength = 0;
                while (matchedLength < limit &&
                    pathSplitted[matchedLength].toLowerCase() ===
                        baseSplitted[matchedLength].toLowerCase()) {
                    ++matchedLength;
                }
                if (!matchedLength) {
                    return absolute;
                }
                if (matchedLength === pathSplitted.length &&
                    matchedLength === baseSplitted.length) {
                    return '.';
                }
                return ((baseSplitted.length > matchedLength
                    ? '..\\'.repeat(baseSplitted.length - matchedLength)
                    : '') + pathSplitted.slice(matchedLength).join('\\'));
            }
            Utils.relativePath = relativePath;
            function commonPath() {
                var paths = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    paths[_i] = arguments[_i];
                }
                if (!paths.length) {
                    return '';
                }
                if (paths.length === 1) {
                    return paths[0];
                }
                var common = paths
                    .map(function (path) { return fso.GetAbsolutePathName(path); })
                    .map(function (path) { return splitPath(path); })
                    .reduce(function (result, path) {
                    var limit = Math.max(result.length, path.length);
                    for (var i = 0; i < limit; ++i) {
                        if (result[i] === path[i]) {
                            continue;
                        }
                        if (i === result.length) {
                            return result;
                        }
                        if (i === path.length) {
                            return path;
                        }
                        return result.slice(0, i);
                    }
                    return result;
                });
                if (common.length === 0) {
                    return undefined;
                }
                if (common.length === 1) {
                    return common[0];
                }
                return common.reduce(function (built, path) { return fso.BuildPath(built, path); });
            }
            Utils.commonPath = commonPath;
            function recursiveFolders(folder) {
                var _a, _b, f, e_8_1;
                var e_8, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, folder];
                        case 1:
                            _d.sent();
                            _d.label = 2;
                        case 2:
                            _d.trys.push([2, 7, 8, 9]);
                            _a = __values(Iterables.from(folder.SubFolders)), _b = _a.next();
                            _d.label = 3;
                        case 3:
                            if (!!_b.done) return [3 /*break*/, 6];
                            f = _b.value;
                            return [5 /*yield**/, __values(recursiveFolders(f))];
                        case 4:
                            _d.sent();
                            _d.label = 5;
                        case 5:
                            _b = _a.next();
                            return [3 /*break*/, 3];
                        case 6: return [3 /*break*/, 9];
                        case 7:
                            e_8_1 = _d.sent();
                            e_8 = { error: e_8_1 };
                            return [3 /*break*/, 9];
                        case 8:
                            try {
                                if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                            }
                            finally { if (e_8) throw e_8.error; }
                            return [7 /*endfinally*/];
                        case 9: return [2 /*return*/];
                    }
                });
            }
            Utils.recursiveFolders = recursiveFolders;
            function recursiveFiles(folder) {
                var _a, _b, f, e_9_1;
                var e_9, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            _d.trys.push([0, 5, 6, 7]);
                            _a = __values(recursiveFolders(folder)), _b = _a.next();
                            _d.label = 1;
                        case 1:
                            if (!!_b.done) return [3 /*break*/, 4];
                            f = _b.value;
                            return [5 /*yield**/, __values(Iterables.from(f.Files))];
                        case 2:
                            _d.sent();
                            _d.label = 3;
                        case 3:
                            _b = _a.next();
                            return [3 /*break*/, 1];
                        case 4: return [3 /*break*/, 7];
                        case 5:
                            e_9_1 = _d.sent();
                            e_9 = { error: e_9_1 };
                            return [3 /*break*/, 7];
                        case 6:
                            try {
                                if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                            }
                            finally { if (e_9) throw e_9.error; }
                            return [7 /*endfinally*/];
                        case 7: return [2 /*return*/];
                    }
                });
            }
            Utils.recursiveFiles = recursiveFiles;
            function recursiveFolderAndFiles(folder) {
                var _a, _b, f, e_10_1;
                var e_10, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            _d.trys.push([0, 6, 7, 8]);
                            _a = __values(recursiveFolders(folder)), _b = _a.next();
                            _d.label = 1;
                        case 1:
                            if (!!_b.done) return [3 /*break*/, 5];
                            f = _b.value;
                            return [4 /*yield*/, f];
                        case 2:
                            _d.sent();
                            return [5 /*yield**/, __values(Iterables.from(f.Files))];
                        case 3:
                            _d.sent();
                            _d.label = 4;
                        case 4:
                            _b = _a.next();
                            return [3 /*break*/, 1];
                        case 5: return [3 /*break*/, 8];
                        case 6:
                            e_10_1 = _d.sent();
                            e_10 = { error: e_10_1 };
                            return [3 /*break*/, 8];
                        case 7:
                            try {
                                if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                            }
                            finally { if (e_10) throw e_10.error; }
                            return [7 /*endfinally*/];
                        case 8: return [2 /*return*/];
                    }
                });
            }
            Utils.recursiveFolderAndFiles = recursiveFolderAndFiles;
            function wildcardToRegExp(pattern) {
                if (!pattern) {
                    return undefined;
                }
                if (pattern.includes('\\')) {
                    throw new Error("Unsupported wildcard: " + pattern);
                }
                var depth = 0;
                var regex = '^' +
                    pattern.replace(/[\^$()\[\]{}+.*?,]/g, function (ch) {
                        switch (ch) {
                            case '*':
                                return '.*';
                            case '?':
                                return '.';
                            case '{':
                                ++depth;
                                return '(?:';
                            case '}':
                                if (depth <= 0) {
                                    throw new Error('Unmatched `}`');
                                }
                                --depth;
                                return ')';
                            case ',':
                                return depth > 0 ? '|' : ',';
                            default:
                                return '\\' + ch;
                        }
                    }) +
                    '$';
                if (depth > 0) {
                    throw new Error('Unmatched `{`');
                }
                return new RegExp(regex, 'i');
            }
            Utils.wildcardToRegExp = wildcardToRegExp;
            /**
             * 指定されたパターンにマッチする全てのファイル/フォルダを順次返すイテレータを返す。
             * @param pattern 検索するファイル/フォルダ名のパターン。`**`はそれ以下の全てのパス、`?`は名前に使用される全ての1文字、`*`は0以上の名前に使用される全ての文字にマッチする。
             * @param basedir 検索を開始するディレクトリへのパス。省略時にはカレントディレクトリ。
             */
            function wildcard(pattern, basedir) {
                basedir = fso.GetAbsolutePathName(basedir || '.');
                var fullpath = /^(?:[A-Z]:|\\\\[^\\\\]+\\[^\\\\]+)?\\/i.test(pattern)
                    ? pattern
                    : fso.BuildPath(basedir, pattern);
                if (!/[*?{]/.test(fullpath)) {
                    if (fso.FolderExists(fullpath)) {
                        return Iterables.of(fso.GetFolder(fullpath));
                    }
                    if (fso.FileExists(fullpath)) {
                        return Iterables.of(fso.GetFile(fullpath));
                    }
                    return Iterables.of();
                }
                var match = fullpath.match(/^(?:[A-Z]:|\\\\[^\\]+\\+[^\\]+)?(?:\\+[^*?{]+)*\\+/i);
                if (!match || match.index !== 0) {
                    throw new Error('');
                }
                if (match.index >= fullpath.length) {
                    throw new Error('');
                }
                var root = match[0];
                if (!fso.FolderExists(root)) {
                    throw new Error("The folder not found: " + root);
                }
                var folder = fso.GetFolder(root);
                var pathes = fullpath
                    .substr(root.length)
                    .split(/\\+/)
                    .map(function (pathAtom, index, array) {
                    if (pathAtom === '') {
                        return function (f) {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, f];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        };
                    }
                    var last = index + 1 === array.length;
                    if (pathAtom === '**') {
                        return last ? recursiveFolderAndFiles : recursiveFolders;
                    }
                    if (/[*?{]/.test(pathAtom)) {
                        var atomPattern_1 = wildcardToRegExp(pathAtom);
                        return function (ff) {
                            var _a, _b, f, e_11_1, _c, _d, f, e_12_1;
                            var e_11, _e, e_12, _f;
                            return __generator(this, function (_g) {
                                switch (_g.label) {
                                    case 0:
                                        _g.trys.push([0, 5, 6, 7]);
                                        _a = __values(Iterables.from(ff.SubFolders)), _b = _a.next();
                                        _g.label = 1;
                                    case 1:
                                        if (!!_b.done) return [3 /*break*/, 4];
                                        f = _b.value;
                                        if (!(atomPattern_1 && atomPattern_1.test(f.Name))) return [3 /*break*/, 3];
                                        return [4 /*yield*/, f];
                                    case 2:
                                        _g.sent();
                                        _g.label = 3;
                                    case 3:
                                        _b = _a.next();
                                        return [3 /*break*/, 1];
                                    case 4: return [3 /*break*/, 7];
                                    case 5:
                                        e_11_1 = _g.sent();
                                        e_11 = { error: e_11_1 };
                                        return [3 /*break*/, 7];
                                    case 6:
                                        try {
                                            if (_b && !_b.done && (_e = _a["return"])) _e.call(_a);
                                        }
                                        finally { if (e_11) throw e_11.error; }
                                        return [7 /*endfinally*/];
                                    case 7:
                                        if (!last) return [3 /*break*/, 15];
                                        _g.label = 8;
                                    case 8:
                                        _g.trys.push([8, 13, 14, 15]);
                                        _c = __values(Iterables.from(ff.Files)), _d = _c.next();
                                        _g.label = 9;
                                    case 9:
                                        if (!!_d.done) return [3 /*break*/, 12];
                                        f = _d.value;
                                        if (!(atomPattern_1 && atomPattern_1.test(f.Name))) return [3 /*break*/, 11];
                                        return [4 /*yield*/, f];
                                    case 10:
                                        _g.sent();
                                        _g.label = 11;
                                    case 11:
                                        _d = _c.next();
                                        return [3 /*break*/, 9];
                                    case 12: return [3 /*break*/, 15];
                                    case 13:
                                        e_12_1 = _g.sent();
                                        e_12 = { error: e_12_1 };
                                        return [3 /*break*/, 15];
                                    case 14:
                                        try {
                                            if (_d && !_d.done && (_f = _c["return"])) _f.call(_c);
                                        }
                                        finally { if (e_12) throw e_12.error; }
                                        return [7 /*endfinally*/];
                                    case 15: return [2 /*return*/];
                                }
                            });
                        };
                    }
                    return function (ff) {
                        var lastpath;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    lastpath = fso.BuildPath(ff.Path, pathAtom);
                                    if (!fso.FolderExists(lastpath)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, fso.GetFolder(lastpath)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                                case 2:
                                    if (!last) return [3 /*break*/, 4];
                                    if (!fso.FileExists(lastpath)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, fso.GetFile(lastpath)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                                case 4: return [2 /*return*/];
                            }
                        });
                    };
                });
                return (function traverse(ff, index) {
                    var _a, _b, item, e_13_1;
                    var e_13, _c;
                    return __generator(this, function (_d) {
                        switch (_d.label) {
                            case 0:
                                if (!(index + 1 === pathes.length)) return [3 /*break*/, 2];
                                return [5 /*yield**/, __values(pathes[index](ff))];
                            case 1:
                                _d.sent();
                                return [2 /*return*/];
                            case 2:
                                _d.trys.push([2, 7, 8, 9]);
                                _a = __values(pathes[index](ff)), _b = _a.next();
                                _d.label = 3;
                            case 3:
                                if (!!_b.done) return [3 /*break*/, 6];
                                item = _b.value;
                                if (!isFolder(item)) {
                                    return [3 /*break*/, 5];
                                }
                                return [5 /*yield**/, __values(traverse(item, index + 1))];
                            case 4:
                                _d.sent();
                                _d.label = 5;
                            case 5:
                                _b = _a.next();
                                return [3 /*break*/, 3];
                            case 6: return [3 /*break*/, 9];
                            case 7:
                                e_13_1 = _d.sent();
                                e_13 = { error: e_13_1 };
                                return [3 /*break*/, 9];
                            case 8:
                                try {
                                    if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                                }
                                finally { if (e_13) throw e_13.error; }
                                return [7 /*endfinally*/];
                            case 9: return [2 /*return*/];
                        }
                    });
                })(folder, 0);
            }
            Utils.wildcard = wildcard;
            function ensureDirectory(dirpath) {
                if (!dirpath) {
                    return fso.GetFolder('.');
                }
                if (fso.FolderExists(dirpath)) {
                    return fso.GetFolder(dirpath);
                }
                if (fso.FileExists(dirpath)) {
                    throw new Error("ファイルが存在しています。: " + dirpath);
                }
                ensureDirectory(fso.GetParentFolderName(dirpath));
                return fso.CreateFolder(dirpath);
            }
            Utils.ensureDirectory = ensureDirectory;
            function resolve() {
                var e_14, _a;
                var paths = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    paths[_i] = arguments[_i];
                }
                var current = fso.GetAbsolutePathName('.');
                try {
                    for (var paths_1 = __values(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {
                        var path = paths_1_1.value;
                        if (isAbsolute(path)) {
                            // 絶対パスの場合は置き換え
                            current = path;
                        }
                        else {
                            // 相対パスの場合は連結
                            current = fso.BuildPath(current, path);
                        }
                    }
                }
                catch (e_14_1) { e_14 = { error: e_14_1 }; }
                finally {
                    try {
                        if (paths_1_1 && !paths_1_1.done && (_a = paths_1["return"])) _a.call(paths_1);
                    }
                    finally { if (e_14) throw e_14.error; }
                }
                return current;
            }
            Utils.resolve = resolve;
            function isAbsolute(path) {
                return /^(?:[A-Z]:|\\\\[^\\\/"<>|*?:]+\\[^\\\/"<>|*?:]+)?\\/i.test(path);
            }
            Utils.isAbsolute = isAbsolute;
        })(Utils = FileSystemObject.Utils || (FileSystemObject.Utils = {}));
    })(FileSystemObject = Scripting.FileSystemObject || (Scripting.FileSystemObject = {}));
})(Scripting || (Scripting = {}));
/// <reference types="windows-installer" />
/// <reference types="filesystemobject-util" />
/// <reference types="iterables" />
/// <reference types="activex-helpers" />
var msiinfo;
(function (msiinfo) {
    var e_15, _a, e_16, _b;
    var fsoU = Scripting.FileSystemObject.Utils;
    var msiOpenDatabaseModeReadOnly = 0 /* msiOpenDatabaseModeReadOnly */;
    WScript.StdOut.WriteLine("パス\t製品名\tバージョン\tProductCode\tPackageCode\tUpgradeCode\t最終更新日時");
    try {
        for (var _c = __values(Iterables.from(WScript.Arguments.Unnamed)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var arg = _d.value;
            try {
                for (var _e = (e_16 = void 0, __values(Iterables.filter(fsoU.wildcard(arg), fsoU.isFile))), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var file = _f.value;
                    var db = installer.OpenDatabase(file.Path, msiOpenDatabaseModeReadOnly);
                    var summaryInfo = db.SummaryInformation(20 /* COUNT_OF_PID */);
                    var subject = summaryInfo.Property(3 /* PID_SUBJECT */);
                    var packageCode = summaryInfo.Property(9 /* PID_REVNUMBER */);
                    var lastSaveTime = new Date(summaryInfo.Property(13 /* PID_LASTSAVE_DTM */)).toISOString();
                    var view = db.OpenView('SELECT `Value` FROM `Property` WHERE `Property`=?');
                    var param = installer.CreateRecord(1);
                    ActiveXObject.set(param, 'StringData', [1], 'ProductVersion');
                    view.Execute(param);
                    var productVersion = view.Fetch().StringData(1);
                    ActiveXObject.set(param, 'StringData', [1], 'ProductCode');
                    view.Execute(param);
                    var productCode = view.Fetch().StringData(1);
                    ActiveXObject.set(param, 'StringData', [1], 'UpgradeCode');
                    view.Execute(param);
                    var upgradeCode = view.Fetch().StringData(1);
                    WScript.StdOut.WriteLine([
                        file.Path,
                        subject,
                        productVersion,
                        productCode,
                        packageCode,
                        upgradeCode,
                        lastSaveTime,
                    ].join('\t'));
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e["return"])) _b.call(_e);
                }
                finally { if (e_16) throw e_16.error; }
            }
        }
    }
    catch (e_15_1) { e_15 = { error: e_15_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c["return"])) _a.call(_c);
        }
        finally { if (e_15) throw e_15.error; }
    }
})(msiinfo || (msiinfo = {}));
})();
]]></script>
</job>
