<?xml version="1.0" encoding="utf-8" ?>
<job>
<object id="fso" progid="Scripting.FileSystemObject"/>
<object id="installer" progid="WindowsInstaller.Installer"/>
<object id="wshShell" progid="WScript.Shell"/>
<object id="shellapp" progid="Shell.Application"/>
<script language="JScript"><![CDATA[
"use strict";
function Symbol(description) {
    var symbols = this.Symbol.symbols;
    var id = "Symbol@@" + description + "@@" + new Date().getTime() + "@@" + Math.random();
    symbols[id] = true;
    return {
        toString: function () {
            return id;
        },
        valueOf: function () {
            return description || '';
        }
    };
}
(function (Symbol) {
})(Symbol || (Symbol = {}));
(function () {
    var symbols = (this.Symbol.symbols = {});
    var registered = {};
    var keys = {};
    this.Symbol.isSymbol = function (symbol) { return !!symbols[symbol.toString()]; };
    this.Symbol["for"] = function (key) {
        var existing = registered[key];
        if (existing) {
            return existing;
        }
        var sym = Symbol(key);
        registered[key] = sym;
        keys[sym.toString()] = key;
        return sym;
    };
    this.Symbol.keyFor = function (sym) { return keys[sym.toString()]; };
})();
(function () {
    this.Symbol.iterator = Symbol('iterator');
    this.Symbol.iterator = Symbol('split');
    function polyfill_iterator(o) {
        var i = 0;
        return {
            next: function () {
                return i < o.length ? { value: o[i++] } : { done: true };
            }
        };
    }
    this.Array.prototype[Symbol.iterator] =
        this.Array.prototype[Symbol.iterator] ||
            function Array_iterator() {
                return polyfill_iterator(this);
            };
    this.String.prototype[Symbol.iterator] =
        this.String.prototype[Symbol.iterator] ||
            function String_iterator() {
                return polyfill_iterator(this);
            };
    if (typeof this.TypedArray === 'function') {
        this.TypedArray.prototype[Symbol.iterator] =
            this.TypedArray.prototype[Symbol.iterator] ||
                function TypedArray_iterator() {
                    return polyfill_iterator(this);
                };
    }
    if (typeof this.Map === 'function') {
        this.Map.prototype[Symbol.iterator] =
            this.Map.prototype[Symbol.iterator] ||
                function Map_iterator() {
                    return polyfill_iterator(this.entries());
                };
    }
    if (typeof this.Set === 'function') {
        this.Set.prototype[Symbol.iterator] =
            this.Set.prototype[Symbol.iterator] ||
                function Set_iterator() {
                    return polyfill_iterator(this.values());
                };
    }
})();
(function () {
    Date.prototype.toISOString =
        Date.prototype.toISOString ||
            function toISOString() {
                return (this.getUTCFullYear() +
                    '-' +
                    ('' + (this.getUTCMonth() + 1)).padStart(2, '0') +
                    '-' +
                    ('' + this.getUTCDate()).padStart(2, '0') +
                    'T' +
                    ('' + this.getUTCHours()).padStart(2, '0') +
                    ':' +
                    ('' + this.getUTCMinutes()).padStart(2, '0') +
                    ':' +
                    ('' + this.getUTCSeconds()).padStart(2, '0') +
                    '.' +
                    ('' + this.getUTCMilliseconds()).padStart(3, '0') +
                    'Z');
            };
    Date.now =
        Date.now ||
            function now() {
                return new Date().getTime();
            };
})();
(function () {
    String.prototype.repeat =
        String.prototype.repeat ||
            function repeat(count) {
                if (count < 0) {
                    throw new Error('repeat count must be non-negative');
                }
                if (count === Infinity) {
                    throw new Error('repeat count must be less than infinity');
                }
                if (this.length === 0) {
                    if (count < 1) {
                        return '';
                    }
                    throw new Error('empty string');
                }
                var r = '';
                while (count-- > 0) {
                    r += this;
                }
                return r;
            };
    var originalSubstr = String.prototype.substr;
    String.prototype.substr = function substr(start, length) {
        if (start < 0) {
            start += this.length;
        }
        length =
            length !== undefined
                ? length < 0
                    ? length + this.length - start
                    : length
                : this.length - start;
        return originalSubstr.call(this, start, length);
    };
    String.prototype.padStart =
        String.prototype.padStart ||
            function padStart(length, paddings) {
                var count = length - this.length;
                if (count <= 0) {
                    return this;
                }
                paddings = paddings || ' ';
                return (paddings
                    .repeat((count + paddings.length - 1) / paddings.length)
                    .substr(0, count) + this);
            };
    String.prototype.padEnd =
        String.prototype.padEnd ||
            function padEnd(length, paddings) {
                var count = length - this.length;
                if (count <= 0) {
                    return this;
                }
                paddings = paddings || ' ';
                return (this +
                    paddings
                        .repeat((count + paddings.length - 1) / paddings.length)
                        .substr(0, count));
            };
    String.prototype.startsWith =
        String.prototype.startsWith ||
            function startsWith(searchString, position) {
                position = position !== undefined ? position : 0;
                return (this.length - position >= searchString.length &&
                    this.lastIndexOf(searchString, position) === position);
            };
    String.prototype.endsWith =
        String.prototype.endsWith ||
            function endsWith(searchString, position) {
                position =
                    (position !== undefined ? position : this.length) - searchString.length;
                return position >= 0 && this.indexOf(searchString, position) === position;
            };
    String.prototype.trim =
        String.prototype.trim ||
            function trim() {
                var match = /(?:\S(?:.*\S)?)(?=\s*$)/.exec(this);
                return (match && match[0]) || '';
            };
    String.prototype.includes =
        String.prototype.includes ||
            function includes(searchString, position) {
                if (typeof position !== 'number') {
                    position = 0;
                }
                return (position + searchString.length <= this.length &&
                    this.indexOf(searchString, position) >= 0);
            };
    String.prototype.split = function split(separator, limit) {
        var str = '' + this;
        if (separator &&
            typeof separator !== 'string' &&
            !(separator instanceof RegExp) &&
            typeof separator[Symbol.split] === 'function') {
            return separator[Symbol.split](str, limit);
        }
        var index = 0;
        var result = [];
        if (separator instanceof RegExp) {
            var prev = 0;
            var re = separator.global
                ? separator
                : new RegExp(separator.source, "g" + (separator.multiline ? 'm' : '') + (separator.ignoreCase ? 'i' : ''));
            while (true) {
                re.lastIndex = index;
                var match = re.exec(str);
                if (!match) {
                    break;
                }
                if (match[0].length) {
                    var next = match.index;
                    var splitted = str.substr(prev, next - prev);
                    result.push(splitted);
                    prev = index = next + match[0].length;
                }
                else {
                    if (index === prev) {
                        index = prev + 1;
                        if (index >= str.length) {
                            return result;
                        }
                        continue;
                    }
                    if (index >= str.length) {
                        break;
                    }
                    var next = index;
                    var splitted = str.substr(prev, next - prev);
                    prev = next;
                    result.push(splitted);
                    ++index;
                }
                for (var i = 1; i < match.length; ++i) {
                    result.push(match[i]);
                }
            }
            result.push(str.substr(prev));
            return result;
        }
        if (!separator) {
            return Array(str.length)
                .fill(0)
                .map(function (_, i) { return str.substr(i, 1); });
        }
        separator = '' + separator;
        while (index < str.length) {
            var next = str.indexOf(separator, index);
            if (next < 0) {
                break;
            }
            result.push(str.substr(index, next - index));
            index = next + separator.length;
        }
        result.push(str.substr(index));
        return result;
    };
})();
(function () {
    this.console = this.console || {};
    function output(stream, messages) {
        stream.WriteLine("[" + new Date().toLocaleTimeString() + "] " + Array.from(messages)
            .map(function (m) { return (m === undefined ? 'undefined' : m === null ? 'null' : m); })
            .join(' '));
    }
    this.console.log =
        this.console.log ||
            function log() {
                output(WScript.StdOut, arguments);
            };
    this.console.error =
        this.console.error ||
            function error() {
                output(WScript.StdErr, arguments);
            };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
(function () {
    Array.isArray =
        Array.isArray ||
            function isArray(obj) {
                return Object.prototype.toString.call(obj) === '[object Array]';
            };
    Array.of =
        Array.of ||
            function of() {
                return Array.prototype.slice.call(arguments);
            };
    Array.from =
        Array.from ||
            function from(arrayLike, mapFn, thisArg) {
                if (typeof mapFn !== 'function' &&
                    Object.prototype.toString.call(mapFn) !== '[object Function]') {
                    mapFn = function (e) { return e; };
                }
                var array;
                if (Array.isArray(arrayLike)) {
                    array = arrayLike.map(mapFn, thisArg);
                }
                else if (typeof arrayLike === 'object' &&
                    (typeof arrayLike.Item === 'function' ||
                        typeof arrayLike.item === 'function')) {
                    array = new Array();
                    var i = 0;
                    for (var e = new Enumerator(arrayLike); !e.atEnd(); e.moveNext()) {
                        array.push(mapFn.call(thisArg, e.item(), i++));
                    }
                }
                else {
                    var len = +arrayLike.length || 0;
                    array = new Array(len);
                    for (var i = 0; i < len; ++i) {
                        array[i] = mapFn.call(thisArg, arrayLike[i], i);
                    }
                }
                return array;
            };
    Array.prototype.some =
        Array.prototype.some ||
            function some(callback, thisObj) {
                for (var i = 0; i < this.length; ++i) {
                    if (!(i in this)) {
                        continue;
                    }
                    if (callback.call(thisObj, this[i], i, this)) {
                        return true;
                    }
                }
                return false;
            };
    Array.prototype.every =
        Array.prototype.every ||
            function every(callback, thisObj) {
                return !this.some(function (e, i, a) { return !callback.call(thisObj, e, i, a); });
            };
    Array.prototype.reduce =
        Array.prototype.reduce ||
            function reduce(callback, initialValue) {
                var index = 0;
                var result = 1 < arguments.length ? initialValue : this[index++];
                for (; index < this.length; ++index) {
                    if (!(index in this)) {
                        continue;
                    }
                    result = callback.call(null, result, this[index], index, this);
                }
                return result;
            };
    Array.prototype.reduceRight =
        Array.prototype.reduceRight ||
            function reduceRight(callback, initialValue) {
                var index = this.length;
                var result = 1 < arguments.length ? initialValue : this[--index];
                while (index-- > 0) {
                    if (!(index in this)) {
                        continue;
                    }
                    result = callback.call(null, result, this[index], index, this);
                }
                return result;
            };
    Array.prototype.forEach =
        Array.prototype.forEach ||
            function forEach(callback, thisObj) {
                this.reduce(function (r, e, i, a) { return callback.call(thisObj, e, i, a) && false; }, false);
            };
    Array.prototype.filter =
        Array.prototype.filter ||
            function filter(callback, thisObj) {
                return this.reduce(function (r, e, i, a) {
                    if (callback.call(thisObj, e, i, a)) {
                        r.push(e);
                    }
                    return r;
                }, []);
            };
    Array.prototype.map =
        Array.prototype.map ||
            function map(callback, thisObj) {
                return this.reduce(function (r, e, i, a) {
                    r[i] = callback.call(thisObj, e, i, a);
                    return r;
                }, []);
            };
    var adjustIndex = function (args, index, length, defaultValue) {
        var value = args.length > index ? +args[index] : NaN;
        if (isNaN(value)) {
            if (defaultValue === undefined) {
                throw new Error('arguments[' + index + '] required');
            }
            value = defaultValue;
        }
        if (value < 0) {
            value += length;
            if (value < 0) {
                value = 0;
            }
        }
        return value;
    };
    Array.prototype.copyWithin =
        Array.prototype.copyWithin ||
            function copyWithin() {
                var target = adjustIndex(arguments, 1, this.length);
                var start = adjustIndex(arguments, 1, this.length, 0);
                var end = adjustIndex(arguments, 2, this.length, this.length);
                var targetEnd = Math.min(target + (end - start), this.length);
                if (target < start) {
                    for (var i = target; i < targetEnd; ++i) {
                        if (!(i in this)) {
                            continue;
                        }
                        this[i] = this[start + i - target];
                    }
                }
                else {
                    for (var i = targetEnd; --i >= target;) {
                        if (!(i in this)) {
                            continue;
                        }
                        this[i] = this[start + i - target];
                    }
                }
                return this;
            };
    Array.prototype.fill =
        Array.prototype.fill ||
            function fill(value) {
                var start = adjustIndex(arguments, 1, this.length, 0);
                var end = adjustIndex(arguments, 2, this.length, this.length);
                for (var i = start; i < end; ++i) {
                    this[i] = value;
                }
                return this;
            };
    Array.prototype.find =
        Array.prototype.find ||
            function find(pred, thisArg) {
                var result;
                this.some(function (e, i, a) { return pred.call(thisArg, e, i, a) && ((result = e), true); });
                return result;
            };
    Array.prototype.findIndex =
        Array.prototype.findIndex ||
            function findIndex(pred, thisArg) {
                var result = -1;
                this.some(function (e, i, a) { return pred.call(thisArg, e, i, a) && ((result = i), true); });
                return result;
            };
    Array.prototype.includes =
        Array.prototype.includes ||
            function includes(searchElement) {
                var e_1, _a;
                try {
                    for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var e = _c.value;
                        if (e === searchElement) {
                            return true;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return false;
            };
    Array.prototype.indexOf =
        Array.prototype.lastIndexOf ||
            function indexOf(searchElement) {
                for (var index = adjustIndex(arguments, 1, this.length, 0); index < this.length; ++index) {
                    if (this[index] === searchElement) {
                        return index;
                    }
                }
                return -1;
            };
    Array.prototype.lastIndexOf =
        Array.prototype.lastIndexOf ||
            function lastIndexOf(searchElement) {
                for (var index = adjustIndex(arguments, 1, this.length, this.length - 1); index >= 0; --index) {
                    if (this[index] === searchElement) {
                        return index;
                    }
                }
                return -1;
            };
    Array.prototype.entries =
        Array.prototype.entries ||
            function entries() {
                return this.map(function (value, index) { return [index, value]; });
            };
    Array.prototype.keys =
        Array.prototype.keys ||
            function keys() {
                return this.map(function (_, index) { return index; });
            };
})();
(function () {
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor',
    ];
    Object.keys =
        Object.keys ||
            function keys(obj) {
                var e_2, _a;
                if (typeof obj !== 'function' &&
                    (typeof obj !== 'object' || obj === null)) {
                    throw new TypeError('Object.keys called on non-object');
                }
                var result = [];
                for (var prop in obj) {
                    if (Symbol.isSymbol(prop)) {
                        continue;
                    }
                    if (!hasOwnProperty.call(obj, prop)) {
                        continue;
                    }
                    result.push(prop);
                }
                if (hasDontEnumBug) {
                    try {
                        for (var dontEnums_1 = __values(dontEnums), dontEnums_1_1 = dontEnums_1.next(); !dontEnums_1_1.done; dontEnums_1_1 = dontEnums_1.next()) {
                            var name = dontEnums_1_1.value;
                            if (!hasOwnProperty.call(obj, name)) {
                                continue;
                            }
                            result.push(name);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (dontEnums_1_1 && !dontEnums_1_1.done && (_a = dontEnums_1["return"])) _a.call(dontEnums_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                return result;
            };
    Object.entries =
        Object.entries ||
            function entries(obj) {
                return Object.keys(obj).map(function (key) { return [key, obj[key]]; });
            };
    Object.values =
        Object.values ||
            function values(obj) {
                return Object.keys(obj).map(function (key) { return obj[key]; });
            };
    Object.create =
        Object.create ||
            function create(proto, propertiesObject) {
                if (typeof proto !== 'object' && typeof proto !== 'function') {
                    throw new TypeError('Object prototype may only be an Object: ' + proto);
                }
                if (proto === null) {
                    throw new Error("This Object.create is a shim and doesn't support 'null' as the first argument.");
                }
                if (propertiesObject !== undefined) {
                    throw new Error("This Object.create is a shim and doesn't support a second argument.");
                }
                var F = function () { };
                F.prototype = proto;
                return new F();
            };
    Object.assign =
        Object.assign ||
            function assign(target) {
                var e_3, _a, e_4, _b;
                var sources = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    sources[_i - 1] = arguments[_i];
                }
                if (target == null) {
                    throw new TypeError('Cannot convert null or undefined to object');
                }
                var to = new Object(target);
                try {
                    for (var sources_1 = __values(sources), sources_1_1 = sources_1.next(); !sources_1_1.done; sources_1_1 = sources_1.next()) {
                        var source = sources_1_1.value;
                        try {
                            for (var _c = (e_4 = void 0, __values(Object.keys(source))), _d = _c.next(); !_d.done; _d = _c.next()) {
                                var name = _d.value;
                                to[name] = source[name];
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_b = _c["return"])) _b.call(_c);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (sources_1_1 && !sources_1_1.done && (_a = sources_1["return"])) _a.call(sources_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return to;
            };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
(function () {
    var ENQUOTE = {
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"': '\\"',
        '/': '\\/',
        '\\': '\\\\'
    };
    var DEQUOTE = Object.keys(ENQUOTE).reduce(function (r, ch) { return ((r[ENQUOTE[ch].charAt(1)] = ch), r); }, {});
    var ENQUOTE_RE = new RegExp("[" + Object.keys(ENQUOTE)
        .map(function (ch) { return (ch === '\\' ? '\\\\' : ch); })
        .join('') + "\0-\u001F]", 'g');
    var DEQUOTE_RE = new RegExp("\\\\(?:([" + Object.keys(DEQUOTE)
        .map(function (ch) { return (ch === '\\' ? '\\\\' : ch); })
        .join('') + "])|u([0-9A-Fa-f]{4}))", 'g');
    var ACCEPT_TYPES = {
        boolean: true,
        number: true,
        object: true,
        string: true,
        undefined: true
    };
    this.JSON = this.JSON || {};
    function enquote(str) {
        return "\"" + str.replace(ENQUOTE_RE, function (ch) {
            return ENQUOTE[ch] ||
                '\\u' +
                    ch
                        .charCodeAt(0)
                        .toString(16)
                        .padStart(4, '0');
        }) + "\"";
    }
    function dequote(quoted) {
        return quoted
            .substr(1, -1)
            .replace(DEQUOTE_RE, function (_, ch, hex) {
            return hex ? String.fromCharCode(parseInt(hex, 16)) : DEQUOTE[ch];
        });
    }
    var cache = {};
    var Parser = (function () {
        function Parser(str) {
            this.str = str;
            this.index = 0;
        }
        Parser.prototype.parse = function (reviewer) {
            var value = this.parseValue();
            this.skipWS();
            if (this.isLeft()) {
                this.failedParsing();
            }
            if (!reviewer) {
                return value;
            }
            return (function recursive(key, subvalue) {
                var e_5, _a;
                if (subvalue && typeof subvalue === 'object') {
                    try {
                        for (var _b = __values(Object.entries(subvalue)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var _d = __read(_c.value, 2), k = _d[0], v = _d[1];
                            subvalue[k] = recursive(k, v);
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                }
                return reviewer(key, subvalue);
            })('', value);
        };
        Parser.prototype.stickyMatch = function (pattern) {
            var re = cache[pattern] ||
                (cache[pattern] = new RegExp("(?:" + pattern + ")|(?=([\\s\\S]))", 'g'));
            re.lastIndex = this.index;
            var match = re.exec(this.str);
            if (!match || match[match.length - 1]) {
                return undefined;
            }
            this.index += match[0].length;
            return match;
        };
        Parser.prototype.failedParsing = function () {
            if (!this.isLeft()) {
                throw new Error("Unexpected the end of string");
            }
            var re = /[^\r\n]*(?:\r?\n|\r|$)/g;
            var _a = __read([0, 0], 2), line = _a[0], bol = _a[1];
            while (true) {
                var match = re.exec(this.str);
                if (!match) {
                    break;
                }
                var eol = match.index + match[0].length;
                if (eol >= this.index) {
                    break;
                }
                ++line;
                bol = eol;
            }
            var column = this.index - bol;
            throw new Error("unexpected: " + this.str.substr(this.index, 10) + " at line: " + line + ", column: " + column);
        };
        Parser.prototype.skipWS = function () {
            this.stickyMatch("\\s+");
        };
        Parser.prototype.scanOne = function (candidates, nothrow) {
            this.skipWS();
            if (!this.isLeft()) {
                return this.failedParsing();
            }
            var ch = this.str.charAt(this.index);
            if (candidates.indexOf(ch) < 0) {
                if (nothrow) {
                    return undefined;
                }
                return this.failedParsing();
            }
            ++this.index;
            return ch;
        };
        Parser.prototype.parseWord = function (pattern, value) {
            this.skipWS();
            return this.stickyMatch(pattern) ? value : this.failedParsing();
        };
        Parser.prototype.parseNumber = function () {
            this.skipWS();
            var match = this.stickyMatch("-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[Ee][-+]?\\d+)?\\b");
            return match ? +match[0] : this.failedParsing();
        };
        Parser.prototype.parseString = function () {
            this.skipWS();
            var match = this.stickyMatch("\"[^\\\\\"]*(?:\\\\.[^\\\\\"]*)*\"");
            return match ? dequote(match[0]) : this.failedParsing();
        };
        Parser.prototype.parseSequence = function (terminater, initialValue, continuousProc) {
            ++this.index;
            var value = initialValue;
            if (!this.scanOne(terminater, true)) {
                var termsep = terminater + ',';
                do {
                    continuousProc(value);
                } while (this.scanOne(termsep) !== terminater);
            }
            return value;
        };
        Parser.prototype.parseValue = function () {
            var _this = this;
            this.skipWS();
            switch (this.str.charAt(this.index)) {
                case 'n':
                    return this.parseWord("null\\b", null);
                case 't':
                    return this.parseWord("true\\b", true);
                case 'f':
                    return this.parseWord("false\\b", false);
                case '-':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    return this.parseNumber();
                case '"':
                    return this.parseString();
                case '[':
                    return this.parseSequence(']', [], function (arr) {
                        arr.push(_this.parseValue());
                    });
                case '{':
                    return this.parseSequence('}', {}, function (obj) {
                        _this.skipWS();
                        var name = _this.parseString();
                        _this.scanOne(':');
                        obj[name] = _this.parseValue();
                    });
            }
            this.failedParsing();
        };
        Parser.prototype.isLeft = function () {
            return this.index < this.str.length;
        };
        return Parser;
    }());
    this.JSON.parse =
        this.JSON.parse ||
            function parse(str, reviewer) {
                return new Parser(str).parse(reviewer);
            };
    this.JSON.stringify =
        this.JSON.stringify ||
            function stringify(value, replacer, space) {
                var validKeys = Array.isArray(replacer) ? replacer : undefined;
                var p = typeof replacer === 'function' ? replacer : undefined;
                var indentUnit = typeof space === 'number'
                    ? ' '.repeat(space)
                    : typeof space === 'string'
                        ? space
                        : '';
                var indent = function (depth) {
                    return (indentUnit && '\n' + indentUnit.repeat(depth)) || '';
                };
                return (function sub(v, depth) {
                    switch (v) {
                        case undefined:
                        case null:
                            return 'null';
                        case true:
                            return 'true';
                        case false:
                            return 'false';
                    }
                    var handlers = {
                        number: function (n) { return (isNaN(n) ? 'null' : '' + n); },
                        string: function (s) { return enquote(s); },
                        object: function (o) {
                            if (typeof o.toJSON === 'function') {
                                var json = o.toJSON();
                                if (json !== o) {
                                    return sub(json, depth);
                                }
                            }
                            if (Array.isArray(o)) {
                                if (o.length === 0) {
                                    return '[]';
                                }
                                return ('[' +
                                    indent(depth + 1) +
                                    o
                                        .map(function (json, i) {
                                        return sub(p ? p('' + i, json) : json, depth + 1) ||
                                            'null';
                                    })
                                        .join(',' + indent(depth + 1)) +
                                    indent(depth) +
                                    ']');
                            }
                            var entries = Object.entries(o)
                                .filter(function (_a) {
                                var _b = __read(_a, 2), k = _b[0], sv = _b[1];
                                return ACCEPT_TYPES[typeof sv] &&
                                    (!validKeys || validKeys.includes(k));
                            })
                                .map(function (_a) {
                                var _b = __read(_a, 2), k = _b[0], sv = _b[1];
                                return [enquote(k), sub(p ? p(k, sv) : sv, depth + 1)];
                            })
                                .filter(function (_a) {
                                var _b = __read(_a, 2), sv = _b[1];
                                return !!sv;
                            })
                                .map(function (k, sv) { return k + ":" + (space ? ' ' : '') + sv; });
                            if (entries.length === 0) {
                                return '{}';
                            }
                            return ('{' +
                                indent(depth + 1) +
                                entries.join(',' + indent(depth + 1)) +
                                indent(depth) +
                                '}');
                        }
                    };
                    var handler = handlers[typeof v];
                    return handler ? handler(v) : '';
                })(value, 0);
            };
})();
(function () {
"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Iterables;
(function (Iterables) {
    /**
     * Iterables のメソッドをメンバに持つIterable。
     *
     * @class IterableEx
     * @implements {I<T>}
     * @template T
     */
    var IterableEx = /** @class */ (function () {
        function IterableEx(param) {
            this.i = typeof param === 'function' ? param() : param;
        }
        IterableEx.prototype[Symbol.iterator] = function () {
            return this.i[Symbol.iterator]();
        };
        IterableEx.prototype.forEach = function (callback) {
            forEach(this, callback);
        };
        IterableEx.prototype.some = function (callback) {
            return some(this, callback);
        };
        IterableEx.prototype.every = function (callback) {
            return every(this, callback);
        };
        IterableEx.prototype.filter = function (callback) {
            return filter(this, callback);
        };
        IterableEx.prototype.map = function (callback) {
            return map(this, callback);
        };
        IterableEx.prototype.reduce = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return reduce.apply(void 0, __spread([this], args));
        };
        IterableEx.prototype.join = function (sep) {
            return join(this, sep);
        };
        return IterableEx;
    }());
    /**
     * Iterableの返す各要素に対してコールバックを呼び出す。
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {(e: T, i: number, x: X) => any} callback 引数で指定したIterableの各要素を渡して呼び出すコールバックを指定する。
     */
    function forEach(x, callback) {
        var e_1, _a;
        var i = 0;
        try {
            for (var x_1 = __values(x), x_1_1 = x_1.next(); !x_1_1.done; x_1_1 = x_1.next()) {
                var e = x_1_1.value;
                callback(e, i++, x);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (x_1_1 && !x_1_1.done && (_a = x_1["return"])) _a.call(x_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    Iterables.forEach = forEach;
    /**
     * Iterableの返す各要素に対してコールバックを呼び出し、一つでもtruthyな値を返すものがあればtrueを返す。
     *
     * truthyな値を返す要素が見つかった時点で各要素へのコールバックの呼び出しを中断する。
     *
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {(e: T, i: number, x: X) => boolean} callback 引数で指定したIterableの各要素を渡して呼び出すコールバックを指定する。
     * @returns {boolean} Iterableの返す各要素に対してコールバックを呼び出し、一つでもtruthyな値を返すものがあればtrueを返す。いずれの要素もfalsyな値を返した場合はfalseを返す。
     */
    function some(x, callback) {
        var e_2, _a;
        var i = 0;
        try {
            for (var x_2 = __values(x), x_2_1 = x_2.next(); !x_2_1.done; x_2_1 = x_2.next()) {
                var e = x_2_1.value;
                if (callback(e, i++, x)) {
                    return true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (x_2_1 && !x_2_1.done && (_a = x_2["return"])) _a.call(x_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return false;
    }
    Iterables.some = some;
    /**
     * Iterableの返す各要素に対してコールバックを呼び出し、一つでもfalsyな値を返すものがあればfalseを返す。
     *
     * falsyな値を返す要素が見つかった時点で各要素へのコールバックの呼び出しを中断する。
     *
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {(e: T, i: number, x: X) => boolean} callback 引数で指定したIterableの各要素を渡して呼び出すコールバックを指定する。
     * @returns {boolean} Iterableの返す各要素に対してコールバックを呼び出し、一つでもfalsyな値を返すものがあればfalseを返す。いずれの要素もtruthyな値を返した場合はtrueを返す。
     */
    function every(x, callback) {
        var e_3, _a;
        var i = 0;
        try {
            for (var x_3 = __values(x), x_3_1 = x_3.next(); !x_3_1.done; x_3_1 = x_3.next()) {
                var e = x_3_1.value;
                if (!callback(e, i++, x)) {
                    return false;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (x_3_1 && !x_3_1.done && (_a = x_3["return"])) _a.call(x_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return true;
    }
    Iterables.every = every;
    function filter(x, callback) {
        return new IterableEx(function () {
            var i, x_4, x_4_1, e, e_4_1;
            var e_4, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        i = 0;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        x_4 = __values(x), x_4_1 = x_4.next();
                        _b.label = 2;
                    case 2:
                        if (!!x_4_1.done) return [3 /*break*/, 5];
                        e = x_4_1.value;
                        if (!callback(e, i++, x)) return [3 /*break*/, 4];
                        return [4 /*yield*/, e];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        x_4_1 = x_4.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_4_1 = _b.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (x_4_1 && !x_4_1.done && (_a = x_4["return"])) _a.call(x_4);
                        }
                        finally { if (e_4) throw e_4.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    }
    Iterables.filter = filter;
    /**
     * Iterableの返す各要素に対してコールバックを呼び出し、コールバックの返す値を要素とするIterableExを生成する。
     *
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @template S この関数が返すIterableExの要素の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {(e: T, i: number, x: X) => S} callback 引数で指定したIterableの各要素を渡して呼び出すコールバックを指定する。
     * @returns {IterableEx<T>} Iterableの返す各要素に対してコールバックを呼び出し、コールバックの返す値を要素とするIterableExを生成して返す。
     */
    function map(x, callback) {
        return new IterableEx(function () {
            var i, x_5, x_5_1, e, e_5_1;
            var e_5, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        i = 0;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        x_5 = __values(x), x_5_1 = x_5.next();
                        _b.label = 2;
                    case 2:
                        if (!!x_5_1.done) return [3 /*break*/, 5];
                        e = x_5_1.value;
                        return [4 /*yield*/, callback(e, i++, x)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        x_5_1 = x_5.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_5_1 = _b.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (x_5_1 && !x_5_1.done && (_a = x_5["return"])) _a.call(x_5);
                        }
                        finally { if (e_5) throw e_5.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    }
    Iterables.map = map;
    function reduce(x, callback, initialValue) {
        var _a, e_6, _b;
        var iterable = x;
        var initialIndex = 0;
        if (arguments.length <= 2) {
            var itr_1 = x[Symbol.iterator]();
            var ir = itr_1.next();
            if (ir.done) {
                throw new Error('Reduce of empty Iterable with no initial value');
            }
            initialIndex = 1;
            iterable = (_a = {},
                _a[Symbol.iterator] = function () {
                    return itr_1;
                },
                _a);
            initialValue = ir.value; // arguments.length <= 2 なら ir.value is S(=T)
        }
        var r = initialValue; // arguments.length > 2 なら initialValue is S(not null)
        var i = initialIndex;
        try {
            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                var e = iterable_1_1.value;
                r = callback(r, e, i++, x);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (iterable_1_1 && !iterable_1_1.done && (_b = iterable_1["return"])) _b.call(iterable_1);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return r;
    }
    Iterables.reduce = reduce;
    /**
     * Iterableの返す各要素を文字列に変換し、結合する。
     *
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {string} sep 結合する際に各要素間に挿入する文字列を指定する。
     * @returns {string} Iterableの返す各要素を文字列に変換し、結合した文字列を返す。
     */
    function join(x, sep) {
        return map(x, function (e) { return e.toString(); }).reduce(function (r, c) { return r + sep + c; });
    }
    Iterables.join = join;
    /**
     * 引数に指定した全てのIterableを結合したIterableExを生成する。
     *
     * @export
     * @template T 全引数の型を指定する。
     * @param {...T} generators Iterableの配列を指定する
     * @returns {Ex<T extends Array<I<infer R>> ? R : never>} 引数に指定した全てのIterableを結合したIterableExを生成して返す。
     */
    function concat() {
        var generators = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            generators[_i] = arguments[_i];
        }
        return new IterableEx(function () {
            var generators_1, generators_1_1, generator, e_7_1;
            var e_7, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, 6, 7]);
                        generators_1 = __values(generators), generators_1_1 = generators_1.next();
                        _b.label = 1;
                    case 1:
                        if (!!generators_1_1.done) return [3 /*break*/, 4];
                        generator = generators_1_1.value;
                        return [5 /*yield**/, __values(generator)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        generators_1_1 = generators_1.next();
                        return [3 /*break*/, 1];
                    case 4: return [3 /*break*/, 7];
                    case 5:
                        e_7_1 = _b.sent();
                        e_7 = { error: e_7_1 };
                        return [3 /*break*/, 7];
                    case 6:
                        try {
                            if (generators_1_1 && !generators_1_1.done && (_a = generators_1["return"])) _a.call(generators_1);
                        }
                        finally { if (e_7) throw e_7.error; }
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    }
    Iterables.concat = concat;
    function isIterable(collection) {
        return typeof collection[Symbol.iterator] === 'function';
    }
    function from(collection) {
        var _a;
        // もともとIterableExの場合はそのまま返す
        if (isIterableEx(collection)) {
            return collection;
        }
        return new IterableEx(
        // Iterableの場合はIterableExのコンストラクタに引数として渡す
        isIterable(collection)
            ? collection
            : // それ以外はEnumeratorを生成してみてコンストラクタに引数として渡す
             (_a = {},
                _a[Symbol.iterator] = function () {
                    var e = new Enumerator(collection);
                    return {
                        next: function () {
                            if (e.atEnd()) {
                                return { done: true };
                            }
                            var value = e.item();
                            e.moveNext();
                            return { done: false, value: value };
                        }
                    };
                },
                _a));
    }
    Iterables.from = from;
    function of() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return from(args);
    }
    Iterables.of = of;
    function max(itr) {
        return reduce(itr, function (mx, e) { return (mx < e ? e : mx); });
    }
    Iterables.max = max;
    function min(itr) {
        return reduce(itr, function (mn, e) { return (mn > e ? e : mn); });
    }
    Iterables.min = min;
    /**
     * IterableExかどうかを判別する
     * @export
     * @param {*} x IterableExかどうかを判別するオブジェクト
     * @returns {x is IterableEx<any>} gがIterableExであれば真を返す。
     */
    function isIterableEx(x) {
        return x && x instanceof IterableEx;
    }
})(Iterables || (Iterables = {}));
/// <reference types="dom3" />
/// <reference types="iterables" />
//
var WScriptUtil;
(function (WScriptUtil) {
    var Arguments;
    (function (Arguments) {
        function Named(params, convArg) {
            var _a = __read(typeof params === 'string' || Array.isArray(params)
                ? [params, convArg]
                : [params.key, params.conv], 2), key = _a[0], conv = _a[1];
            var keys = Array.isArray(key) ? key : [key];
            var value = (function () {
                var e_8, _a;
                try {
                    for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                        var k = keys_1_1.value;
                        if (WScript.Arguments.Named.Exists(k)) {
                            return WScript.Arguments.Named(k);
                        }
                    }
                }
                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                finally {
                    try {
                        if (keys_1_1 && !keys_1_1.done && (_a = keys_1["return"])) _a.call(keys_1);
                    }
                    finally { if (e_8) throw e_8.error; }
                }
                return undefined;
            })();
            return conv ? conv(value) : value;
        }
        Arguments.Named = Named;
        function Switch(keys) {
            var e_9, _a;
            try {
                for (var _b = __values(Array.isArray(keys) ? keys : [keys]), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (WScript.Arguments.Named.Exists(key)) {
                        return true;
                    }
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
                }
                finally { if (e_9) throw e_9.error; }
            }
            return false;
        }
        Arguments.Switch = Switch;
        function Unnamed() {
            return Iterables.from(WScript.Arguments.Unnamed);
        }
        Arguments.Unnamed = Unnamed;
    })(Arguments = WScriptUtil.Arguments || (WScriptUtil.Arguments = {}));
    function validateParameters() {
        var e_10, _a;
        if (WScript.Arguments.Named.Exists('?') ||
            WScript.Arguments.Named.Exists('help')) {
            WScript.Arguments.ShowUsage();
            return WScript.Quit(0);
        }
        var doc = WScript.CreateObject('MSXML2.DOMDocument.6.0');
        doc.load(WScript.ScriptFullName);
        var hasError = false;
        try {
            for (var _b = __values(Iterables.from(doc.selectNodes('/job/runtime/named'))), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                if (node.nodeType !== DOM3.ELEMENT_NODE) {
                    continue;
                }
                var name = node.getAttribute('name');
                if (!name) {
                    continue;
                }
                var required = node.getAttribute('required') === 'true';
                if (!WScript.Arguments.Named.Exists(name)) {
                    if (required) {
                        WScript.Echo(name + " は必須パラメータです。");
                        hasError = true;
                    }
                    continue;
                }
                var value = WScript.Arguments.Named(name);
                switch (node.getAttribute('type')) {
                    case 'string':
                        if (typeof value !== 'string') {
                            WScript.Echo(name + " には文字列を指定(/" + name + ":文字列)してください。");
                            hasError = true;
                            continue;
                        }
                        break;
                    case 'boolean':
                        if (typeof value !== 'boolean') {
                            WScript.Echo(name + " にはオン(/" + name + "+)、もしくはオフ(/" + name + "-)を指定してください。");
                            hasError = true;
                            continue;
                        }
                        break;
                    default:
                        // case 'simple':
                        if (typeof value !== 'undefined') {
                            WScript.Echo(name + " にはパラメータだけ(/" + name + ")を指定してください。");
                            hasError = true;
                            continue;
                        }
                        break;
                }
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
            }
            finally { if (e_10) throw e_10.error; }
        }
        var unnamedElement = doc.selectSingleNode('/job/runtime/unnamed');
        if (unnamedElement &&
            unnamedElement.nodeType === DOM3.ELEMENT_NODE) {
            var isMany = unnamedElement.getAttribute('many') === 'true';
            var required = (function (value) {
                return !value ? 0 : value === 'true' ? 1 : value === 'false' ? 0 : +value;
            })(unnamedElement.getAttribute('required'));
            if (WScript.Arguments.Unnamed.length < required) {
                WScript.Echo("パラメータが不足しています(必要数: " + required + "})。");
                hasError = true;
            }
            else if (WScript.Arguments.Unnamed.length > required && !isMany) {
                WScript.Echo(required > 0
                    ? "パラメータが多過ぎます(必要数: " + required + "})。"
                    : "パラメータは不要です。");
                hasError = true;
            }
        }
        if (hasError) {
            return WScript.Quit(1);
        }
    }
    WScriptUtil.validateParameters = validateParameters;
})(WScriptUtil || (WScriptUtil = {}));
/// <reference types="activex-scripting" />
/// <reference types="iterables" />
var Scripting;
(function (Scripting) {
    var FileSystemObject;
    (function (FileSystemObject) {
        var Utils;
        (function (Utils) {
            function isFolder(f) {
                return 'Files' in f;
            }
            Utils.isFolder = isFolder;
            function isFile(f) {
                return !isFolder(f);
            }
            Utils.isFile = isFile;
            function sort(array) {
                return array.sort(function (a, b) {
                    var aa = a.Name.toUpperCase();
                    var bb = b.Name.toUpperCase();
                    return aa === bb ? 0 : aa < bb ? -1 : 1;
                });
            }
            function files(folder) {
                return sort(__spread(Iterables.from(folder.Files)));
            }
            Utils.files = files;
            function subFolders(folder) {
                return sort(__spread(Iterables.from(folder.SubFolders)));
            }
            Utils.subFolders = subFolders;
            function filesAndSubFolders(folder) {
                return sort(__spread(Iterables.concat(Iterables.from(folder.Files), Iterables.from(folder.SubFolders))));
            }
            Utils.filesAndSubFolders = filesAndSubFolders;
            function getItem(path) {
                if (fso.FileExists(path)) {
                    return fso.GetFile(path);
                }
                if (fso.FolderExists(path)) {
                    return fso.GetFolder(path);
                }
                return undefined;
            }
            Utils.getItem = getItem;
            function splitPath(path) {
                var splited = [];
                var match = /^(?:([A-Z]):|\\{2,}([^\\]+)\\+([^\\]+))?(\\+|$)?/i.exec(path);
                if (match) {
                    if (match[1]) {
                        if (!match[4]) {
                            throw new Error("ドライブ指定時には絶対パスで指定してください");
                        }
                        splited.push(match[1] + ":\\");
                    }
                    else if (match[2]) {
                        splited.push("\\\\" + match[2] + ":\\" + match[3] + "\\");
                    }
                    else if (match[4]) {
                        splited.push('\\');
                    }
                    if (match[0]) {
                        path = path.substr(match[0].length);
                    }
                }
                if (!path) {
                    return splited;
                }
                return splited.concat(path.split(/\\+/));
            }
            Utils.splitPath = splitPath;
            function relativePath(path, base) {
                var absolute = fso.GetAbsolutePathName(path);
                var pathSplitted = splitPath(absolute);
                var aa = fso.GetAbsolutePathName(base || '.');
                var baseSplitted = splitPath(aa);
                var limit = Math.min(pathSplitted.length, baseSplitted.length);
                var matchedLength = 0;
                while (matchedLength < limit &&
                    pathSplitted[matchedLength].toLowerCase() ===
                        baseSplitted[matchedLength].toLowerCase()) {
                    ++matchedLength;
                }
                if (!matchedLength) {
                    return absolute;
                }
                if (matchedLength === pathSplitted.length &&
                    matchedLength === baseSplitted.length) {
                    return '.';
                }
                return ((baseSplitted.length > matchedLength
                    ? '..\\'.repeat(baseSplitted.length - matchedLength)
                    : '') + pathSplitted.slice(matchedLength).join('\\'));
            }
            Utils.relativePath = relativePath;
            function commonPath() {
                var paths = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    paths[_i] = arguments[_i];
                }
                if (!paths.length) {
                    return '';
                }
                if (paths.length === 1) {
                    return paths[0];
                }
                var common = paths
                    .map(function (path) { return fso.GetAbsolutePathName(path); })
                    .map(function (path) { return splitPath(path); })
                    .reduce(function (result, path) {
                    var limit = Math.max(result.length, path.length);
                    for (var i = 0; i < limit; ++i) {
                        if (result[i] === path[i]) {
                            continue;
                        }
                        if (i === result.length) {
                            return result;
                        }
                        if (i === path.length) {
                            return path;
                        }
                        return result.slice(0, i);
                    }
                    return result;
                });
                if (common.length === 0) {
                    return undefined;
                }
                if (common.length === 1) {
                    return common[0];
                }
                return common.reduce(function (built, path) { return fso.BuildPath(built, path); });
            }
            Utils.commonPath = commonPath;
            function recursiveFolders(folder) {
                var _a, _b, f, e_11_1;
                var e_11, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, folder];
                        case 1:
                            _d.sent();
                            _d.label = 2;
                        case 2:
                            _d.trys.push([2, 7, 8, 9]);
                            _a = __values(Iterables.from(folder.SubFolders)), _b = _a.next();
                            _d.label = 3;
                        case 3:
                            if (!!_b.done) return [3 /*break*/, 6];
                            f = _b.value;
                            return [5 /*yield**/, __values(recursiveFolders(f))];
                        case 4:
                            _d.sent();
                            _d.label = 5;
                        case 5:
                            _b = _a.next();
                            return [3 /*break*/, 3];
                        case 6: return [3 /*break*/, 9];
                        case 7:
                            e_11_1 = _d.sent();
                            e_11 = { error: e_11_1 };
                            return [3 /*break*/, 9];
                        case 8:
                            try {
                                if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                            }
                            finally { if (e_11) throw e_11.error; }
                            return [7 /*endfinally*/];
                        case 9: return [2 /*return*/];
                    }
                });
            }
            Utils.recursiveFolders = recursiveFolders;
            function recursiveFiles(folder) {
                var _a, _b, f, e_12_1;
                var e_12, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            _d.trys.push([0, 5, 6, 7]);
                            _a = __values(recursiveFolders(folder)), _b = _a.next();
                            _d.label = 1;
                        case 1:
                            if (!!_b.done) return [3 /*break*/, 4];
                            f = _b.value;
                            return [5 /*yield**/, __values(Iterables.from(f.Files))];
                        case 2:
                            _d.sent();
                            _d.label = 3;
                        case 3:
                            _b = _a.next();
                            return [3 /*break*/, 1];
                        case 4: return [3 /*break*/, 7];
                        case 5:
                            e_12_1 = _d.sent();
                            e_12 = { error: e_12_1 };
                            return [3 /*break*/, 7];
                        case 6:
                            try {
                                if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                            }
                            finally { if (e_12) throw e_12.error; }
                            return [7 /*endfinally*/];
                        case 7: return [2 /*return*/];
                    }
                });
            }
            Utils.recursiveFiles = recursiveFiles;
            function recursiveFolderAndFiles(folder) {
                var _a, _b, f, e_13_1;
                var e_13, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            _d.trys.push([0, 6, 7, 8]);
                            _a = __values(recursiveFolders(folder)), _b = _a.next();
                            _d.label = 1;
                        case 1:
                            if (!!_b.done) return [3 /*break*/, 5];
                            f = _b.value;
                            return [4 /*yield*/, f];
                        case 2:
                            _d.sent();
                            return [5 /*yield**/, __values(Iterables.from(f.Files))];
                        case 3:
                            _d.sent();
                            _d.label = 4;
                        case 4:
                            _b = _a.next();
                            return [3 /*break*/, 1];
                        case 5: return [3 /*break*/, 8];
                        case 6:
                            e_13_1 = _d.sent();
                            e_13 = { error: e_13_1 };
                            return [3 /*break*/, 8];
                        case 7:
                            try {
                                if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                            }
                            finally { if (e_13) throw e_13.error; }
                            return [7 /*endfinally*/];
                        case 8: return [2 /*return*/];
                    }
                });
            }
            Utils.recursiveFolderAndFiles = recursiveFolderAndFiles;
            function wildcardToRegExp(pattern) {
                if (!pattern) {
                    return undefined;
                }
                if (pattern.includes('\\')) {
                    throw new Error("Unsupported wildcard: " + pattern);
                }
                var depth = 0;
                var regex = '^' +
                    pattern.replace(/[\^$()\[\]{}+.*?,]/g, function (ch) {
                        switch (ch) {
                            case '*':
                                return '.*';
                            case '?':
                                return '.';
                            case '{':
                                ++depth;
                                return '(?:';
                            case '}':
                                if (depth <= 0) {
                                    throw new Error('Unmatched `}`');
                                }
                                --depth;
                                return ')';
                            case ',':
                                return depth > 0 ? '|' : ',';
                            default:
                                return '\\' + ch;
                        }
                    }) +
                    '$';
                if (depth > 0) {
                    throw new Error('Unmatched `{`');
                }
                return new RegExp(regex, 'i');
            }
            Utils.wildcardToRegExp = wildcardToRegExp;
            /**
             * 指定されたパターンにマッチする全てのファイル/フォルダを順次返すイテレータを返す。
             * @param pattern 検索するファイル/フォルダ名のパターン。`**`はそれ以下の全てのパス、`?`は名前に使用される全ての1文字、`*`は0以上の名前に使用される全ての文字にマッチする。
             * @param basedir 検索を開始するディレクトリへのパス。省略時にはカレントディレクトリ。
             */
            function wildcard(pattern, basedir) {
                basedir = fso.GetAbsolutePathName(basedir || '.');
                var fullpath = /^(?:[A-Z]:|\\\\[^\\\\]+\\[^\\\\]+)?\\/i.test(pattern)
                    ? pattern
                    : fso.BuildPath(basedir, pattern);
                if (!/[*?{]/.test(fullpath)) {
                    if (fso.FolderExists(fullpath)) {
                        return Iterables.of(fso.GetFolder(fullpath));
                    }
                    if (fso.FileExists(fullpath)) {
                        return Iterables.of(fso.GetFile(fullpath));
                    }
                    return Iterables.of();
                }
                var match = fullpath.match(/^(?:[A-Z]:|\\\\[^\\]+\\+[^\\]+)?(?:\\+[^*?{]+)*\\+/i);
                if (!match || match.index !== 0) {
                    throw new Error('');
                }
                if (match.index >= fullpath.length) {
                    throw new Error('');
                }
                var root = match[0];
                if (!fso.FolderExists(root)) {
                    throw new Error("The folder not found: " + root);
                }
                var folder = fso.GetFolder(root);
                var pathes = fullpath
                    .substr(root.length)
                    .split(/\\+/)
                    .map(function (pathAtom, index, array) {
                    if (pathAtom === '') {
                        return function (f) {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, f];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        };
                    }
                    var last = index + 1 === array.length;
                    if (pathAtom === '**') {
                        return last ? recursiveFolderAndFiles : recursiveFolders;
                    }
                    if (/[*?{]/.test(pathAtom)) {
                        var atomPattern_1 = wildcardToRegExp(pathAtom);
                        return function (ff) {
                            var _a, _b, f, e_14_1, _c, _d, f, e_15_1;
                            var e_14, _e, e_15, _f;
                            return __generator(this, function (_g) {
                                switch (_g.label) {
                                    case 0:
                                        _g.trys.push([0, 5, 6, 7]);
                                        _a = __values(Iterables.from(ff.SubFolders)), _b = _a.next();
                                        _g.label = 1;
                                    case 1:
                                        if (!!_b.done) return [3 /*break*/, 4];
                                        f = _b.value;
                                        if (!(atomPattern_1 && atomPattern_1.test(f.Name))) return [3 /*break*/, 3];
                                        return [4 /*yield*/, f];
                                    case 2:
                                        _g.sent();
                                        _g.label = 3;
                                    case 3:
                                        _b = _a.next();
                                        return [3 /*break*/, 1];
                                    case 4: return [3 /*break*/, 7];
                                    case 5:
                                        e_14_1 = _g.sent();
                                        e_14 = { error: e_14_1 };
                                        return [3 /*break*/, 7];
                                    case 6:
                                        try {
                                            if (_b && !_b.done && (_e = _a["return"])) _e.call(_a);
                                        }
                                        finally { if (e_14) throw e_14.error; }
                                        return [7 /*endfinally*/];
                                    case 7:
                                        if (!last) return [3 /*break*/, 15];
                                        _g.label = 8;
                                    case 8:
                                        _g.trys.push([8, 13, 14, 15]);
                                        _c = __values(Iterables.from(ff.Files)), _d = _c.next();
                                        _g.label = 9;
                                    case 9:
                                        if (!!_d.done) return [3 /*break*/, 12];
                                        f = _d.value;
                                        if (!(atomPattern_1 && atomPattern_1.test(f.Name))) return [3 /*break*/, 11];
                                        return [4 /*yield*/, f];
                                    case 10:
                                        _g.sent();
                                        _g.label = 11;
                                    case 11:
                                        _d = _c.next();
                                        return [3 /*break*/, 9];
                                    case 12: return [3 /*break*/, 15];
                                    case 13:
                                        e_15_1 = _g.sent();
                                        e_15 = { error: e_15_1 };
                                        return [3 /*break*/, 15];
                                    case 14:
                                        try {
                                            if (_d && !_d.done && (_f = _c["return"])) _f.call(_c);
                                        }
                                        finally { if (e_15) throw e_15.error; }
                                        return [7 /*endfinally*/];
                                    case 15: return [2 /*return*/];
                                }
                            });
                        };
                    }
                    return function (ff) {
                        var lastpath;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    lastpath = fso.BuildPath(ff.Path, pathAtom);
                                    if (!fso.FolderExists(lastpath)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, fso.GetFolder(lastpath)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                                case 2:
                                    if (!last) return [3 /*break*/, 4];
                                    if (!fso.FileExists(lastpath)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, fso.GetFile(lastpath)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                                case 4: return [2 /*return*/];
                            }
                        });
                    };
                });
                return (function traverse(ff, index) {
                    var _a, _b, item, e_16_1;
                    var e_16, _c;
                    return __generator(this, function (_d) {
                        switch (_d.label) {
                            case 0:
                                if (!(index + 1 === pathes.length)) return [3 /*break*/, 2];
                                return [5 /*yield**/, __values(pathes[index](ff))];
                            case 1:
                                _d.sent();
                                return [2 /*return*/];
                            case 2:
                                _d.trys.push([2, 7, 8, 9]);
                                _a = __values(pathes[index](ff)), _b = _a.next();
                                _d.label = 3;
                            case 3:
                                if (!!_b.done) return [3 /*break*/, 6];
                                item = _b.value;
                                if (!isFolder(item)) {
                                    return [3 /*break*/, 5];
                                }
                                return [5 /*yield**/, __values(traverse(item, index + 1))];
                            case 4:
                                _d.sent();
                                _d.label = 5;
                            case 5:
                                _b = _a.next();
                                return [3 /*break*/, 3];
                            case 6: return [3 /*break*/, 9];
                            case 7:
                                e_16_1 = _d.sent();
                                e_16 = { error: e_16_1 };
                                return [3 /*break*/, 9];
                            case 8:
                                try {
                                    if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                                }
                                finally { if (e_16) throw e_16.error; }
                                return [7 /*endfinally*/];
                            case 9: return [2 /*return*/];
                        }
                    });
                })(folder, 0);
            }
            Utils.wildcard = wildcard;
            function ensureDirectory(dirpath) {
                if (!dirpath) {
                    return fso.GetFolder('.');
                }
                if (fso.FolderExists(dirpath)) {
                    return fso.GetFolder(dirpath);
                }
                if (fso.FileExists(dirpath)) {
                    throw new Error("ファイルが存在しています。: " + dirpath);
                }
                ensureDirectory(fso.GetParentFolderName(dirpath));
                return fso.CreateFolder(dirpath);
            }
            Utils.ensureDirectory = ensureDirectory;
            function resolve() {
                var e_17, _a;
                var paths = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    paths[_i] = arguments[_i];
                }
                var current = fso.GetAbsolutePathName('.');
                try {
                    for (var paths_1 = __values(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {
                        var path = paths_1_1.value;
                        if (isAbsolute(path)) {
                            // 絶対パスの場合は置き換え
                            current = path;
                        }
                        else {
                            // 相対パスの場合は連結
                            current = fso.BuildPath(current, path);
                        }
                    }
                }
                catch (e_17_1) { e_17 = { error: e_17_1 }; }
                finally {
                    try {
                        if (paths_1_1 && !paths_1_1.done && (_a = paths_1["return"])) _a.call(paths_1);
                    }
                    finally { if (e_17) throw e_17.error; }
                }
                return current;
            }
            Utils.resolve = resolve;
            function isAbsolute(path) {
                return /^(?:[A-Z]:|\\\\[^\\\/"<>|*?:]+\\[^\\\/"<>|*?:]+)?\\/i.test(path);
            }
            Utils.isAbsolute = isAbsolute;
        })(Utils = FileSystemObject.Utils || (FileSystemObject.Utils = {}));
    })(FileSystemObject = Scripting.FileSystemObject || (Scripting.FileSystemObject = {}));
})(Scripting || (Scripting = {}));
/// <reference types="wscript-util" />
/// <reference types="iterables" />
/// <reference types="filesystemobject-util" />
/// <reference types="windows-installer" />
/// <reference types="dom3" />
/// <reference types="activex-shell" />
var filever;
(function (filever) {
    var fsoU = Scripting.FileSystemObject.Utils;
    /**
     * ファイルのバージョンを取得する。
     *
     * 具体的に取得するバージョンは以下のとおり。
     *
     * - msiはPropetyテーブルのProductVersion
     * - mspはPatch情報XMLのUpdatedVersion
     * - exeやdllなどバージョンリソースのあるものはそのバージョンリソース
     * - バージョンリソースの無いものは`-`
     *
     * @param filepath バージョンを取得するファイルへのパス。
     * @return \{{{string}}\} ファイルのバージョン。
     */
    function getFileVersion(filepath) {
        if (/\.msi$/i.test(filepath)) {
            var db = installer.OpenDatabase(filepath, 0);
            var view = db.OpenView("SELECT Value FROM Property WHERE Property = 'ProductVersion'");
            try {
                view.Execute();
                var record = view.Fetch();
                return record.StringData(1);
            }
            finally {
                view.Close();
            }
        }
        if (/\.msp$/i.test(filepath)) {
            var xml = installer.ExtractPatchXMLData(filepath);
            var doc = WScript.CreateObject('MSXML2.DOMDocument.6.0');
            doc.async = false;
            doc.setProperty('SelectionNamespaces', "xmlns:patch='http://www.microsoft.com/msi/patch_applicability.xsd'");
            if (!doc.loadXML(xml)) {
                throw new Error(filepath + ":\n    errorCode: " + doc.parseError.errorCode + "\n    reason: " + doc.parseError.reason + "\n    line: " + doc.parseError.line + "\n    linepos: " + doc.parseError.linepos + "\n    filepos: " + doc.parseError.filepos + "\n    srcText: " + doc.parseError.srcText + "\n    url: " + doc.parseError.url);
            }
            return doc.selectSingleNode('/patch:MsiPatch/patch:TargetProduct/patch:UpdatedVersion').text;
        }
        return installer.FileVersion(filepath) || '-';
    }
    /** ファイル内容からのハッシュを16進文字列で返す。 */
    function FileHash(filepath) {
        var e_18, _a;
        var record = installer.FileHash(filepath, 0);
        var hexhash = '';
        for (var i = 1; i <= 4; ++i) {
            var hash = record.IntegerData(i);
            try {
                for (var _b = (e_18 = void 0, __values([(hash >> 16) & 0xffff, hash & 0xffff])), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var h = _c.value;
                    hexhash += h.toString(16).padStart(4, '0');
                }
            }
            catch (e_18_1) { e_18 = { error: e_18_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
                }
                finally { if (e_18) throw e_18.error; }
            }
        }
        return hexhash;
    }
    /** 電子署名済みであれば署名者を返す。 */
    function checkSignature(file) {
        // 署名チェックツールの実行
        var process = wshShell.Exec("\"" + signtool() + "\" verify /pa /v \"" + file.Path + "\"");
        // 標準出力および標準エラー出力から署名情報を取得
        var signer = '';
        var inSigningCertificateChain = false;
        var timestamped = false;
        while (!process.StdOut.AtEndOfStream || !process.StdErr.AtEndOfStream) {
            var line = (process.StdOut.AtEndOfStream
                ? process.StdErr.ReadLine()
                : process.StdOut.ReadLine()).trim();
            // 署名
            if (line.startsWith('Signing Certificate Chain:')) {
                inSigningCertificateChain = true;
                continue;
            }
            // 時刻署名
            if (line.startsWith('Timestamp Verified by:')) {
                inSigningCertificateChain = false;
                continue;
            }
            // 署名確認成功
            if (line.startsWith('Successfully verified: ')) {
                inSigningCertificateChain = false;
                break;
            }
            // 時刻署名の確認
            if (line.startsWith('The signature is timestamped: ')) {
                timestamped = true;
                continue;
            }
            // 拡張子の形式になっていないので無視
            if (line ===
                'SignTool Error: This file format cannot be verified because it is not') {
                signer = '署名対象外';
                break;
            }
            // 署名していない
            if (line === 'SignTool Error: No signature found.') {
                signer = '署名していない';
                break;
            }
            // 署名エラー
            if (line.startsWith('SignTool Error: ')) {
                signer = "!!!!署名エラー(" + line.substr(16) + ")!!!!";
                break;
            }
            // 署名済み
            if (inSigningCertificateChain && line.startsWith('Issued to: ')) {
                signer = line.substr(11);
                continue;
            }
        }
        // サインツールのエラー
        if (!signer) {
            signer = '!!!!sintool error!!!!';
        }
        // 時刻署名しているかどうかもチェック
        if (!timestamped) {
            signer = "!!!!時刻署名なし!!!!(" + signer + ")";
        }
        return signer;
    }
    // コンテンツの作成日時を返す
    function GetContentCreationDate(file) {
        if (fso.GetExtensionName(file.Name).toLowerCase() === 'msp') {
            // MSPだけはMsiPatchMetadataのCreationTimeUTCから取得
            var database = installer.OpenDatabase(file.Path, 32 /* msiOpenDatabaseModePatchFile */);
            var view = database.OpenView("SELECT Value FROM MsiPatchMetadata WHERE Property = 'CreationTimeUTC'");
            try {
                view.Execute();
                var record = view.Fetch();
                if (!record) {
                    return;
                }
                var match = record
                    .StringData(1)
                    .match(/^(\d+)-(\d+)-(\d+)\s+(\d+:\d+)$/);
                if (!match) {
                    return;
                }
                return new Date(match[1] + "/" + match[2] + "/" + match[3] + " " + match[4]).toLocaleString();
            }
            finally {
                view.Close();
            }
        }
        var folder = shellapp.NameSpace(file.ParentFolder.Path);
        if (!folder) {
            return;
        }
        var folderItem = folder.ParseName(file.Name);
        if (!folderItem) {
            return;
        }
        var timestamp = folderItem.ExtendedProperty('{F29F85E0-4FF9-1068-AB91-08002B27B3D9} 12');
        if (timestamp !== undefined) {
            return new Date(timestamp).toLocaleString(); // コンテンツの作成日時
        }
    }
    // ADODB.Streamが返すバイナリストリームをJavaScriptで扱えるように変換するため、dataType: 'bin.hex'を使う
    var el = WScript.CreateObject('MSXML2.DOMDocument.6.0').createElement('t');
    // ADODB.Streamからバイナリデータを読み込む
    function readStream(stream, pos, length, bigEndian) {
        if (pos > stream.Size) {
            return null;
        }
        stream.Position = pos;
        el.dataType = 'bin.hex';
        el.nodeTypedValue = stream.Read(length);
        return parseInt(bigEndian
            ? el.text
            : el.text
                .split(/(?=(?:[0-9a-f]{2})+$)/)
                .reverse()
                .join(''), 16);
    }
    // ビルドした日時を返す
    function GetBuildDate(file) {
        if (!fsoU.isFile(file)) {
            return;
        }
        // MSI/MSPは作成日時
        switch (fso.GetExtensionName(file.Name).toLowerCase()) {
            case 'msi':
            case 'msp':
                return GetContentCreationDate(file);
        }
        var STREAM = WScript.CreateObject('ADODB.Stream');
        STREAM.Mode = 3 /* adModeReadWrite */;
        STREAM.Type = 1 /* adTypeBinary */;
        STREAM.Open();
        try {
            STREAM.LoadFromFile(file.Path);
            if (readStream(STREAM, 0, 2, true) !== 0x4d5a /* MZ */) {
                return;
            }
            var pePos = readStream(STREAM, 0x3c, 4);
            if (pePos === null) {
                return;
            }
            if (readStream(STREAM, pePos, 2, true) !== 0x5045 /* PE */) {
                return;
            }
            var timestamp = readStream(STREAM, pePos + 8, 4);
            if (timestamp === null) {
                return;
            }
            // timestampは1970年1月1日午前0時0分0秒からの経過秒数なのでミリ秒に変換
            return new Date(timestamp * 1000).toLocaleString();
        }
        finally {
            STREAM.Close();
        }
    }
    /**
     * ワイルドカード、相対パスの基準ディレクトリ。
     * コマンドラインオプション/basedirで変更可能。
     */
    var basedir = WScriptUtil.Arguments.Named(['BaseDir', 'Base', 'B']) || '.';
    /**
     * 出力するファイル情報のフォーマット。
     * 省略時は`$r\t$v`(相対パスとバージョン)
     */
    var format = WScriptUtil.Arguments.Named(['Format', 'F']) || '$r\t$v';
    /**
     * 追加書き込みするかどうか。省略時には新規書き込み。
     */
    var appendMode = WScriptUtil.Arguments.Switch(['Append', 'A']);
    /**
     * 出力先のファイル。省略時には標準出力を使う。
     */
    var output = WScriptUtil.Arguments.Named({
        key: ['Output', 'Out', 'O'],
        conv: function (outputPath) {
            if (!outputPath) {
                return WScript.StdOut;
            }
            var mode = appendMode
                ? 8 /* ForAppending */
                : 2 /* ForWriting */;
            return fso.OpenTextFile(outputPath, mode, true, 0 /* TristateFalse */);
        }
    });
    /**
     * 使い方を表示するかどうか。
     */
    var showHelp = WScriptUtil.Arguments.Switch(['Help', 'H', '?']);
    /** 無視するファイル・ディレクトリを判定する。 FileOnlyが指定されていればファイル以外を無視、DirectoryOnlyが指定されていればディレクトリ以外を無視。 */
    var ignored = WScriptUtil.Arguments.Switch('FileOnly')
        ? function (file) { return !fsoU.isFile(file); }
        : WScriptUtil.Arguments.Switch('DirectoryOnly')
            ? function (file) { return !fsoU.isFolder(file); }
            : function () { return false; };
    // コマンドラインオプションでsigntoolの指定があればそちらを優先する。
    var signtoolCache = WScriptUtil.Arguments.Named('SignTool');
    // 利用されるまでパス解決を行わないようにする
    function signtool() {
        var e_19, _a;
        // コマンドラインオプションでの指定があった場合はそちらを、既にコマンドを実行した場合は前回の結果を使用する。
        if (signtoolCache !== undefined) {
            return signtoolCache;
        }
        if (fso.FileExists('signtool.exe')) {
            // カレントディレクトリにあれば'signtool'だけでいい
            return (signtoolCache = 'signtool');
        }
        var onscriptpath = fso.BuildPath(fso.GetParentFolderName(WScript.ScriptFullName), 'signtool.exe');
        if (fso.FileExists(onscriptpath)) {
            // スクリプトと同じディレクトリにあればそれを使う
            return (signtoolCache = onscriptpath);
        }
        try {
            for (var _b = __values(wshShell.Environment.Item('PATH').split(/;/)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var path = _c.value;
                if (fso.FileExists(fso.BuildPath(path.replace(/^"(.*)"$/, '$1'), 'signtool.exe'))) {
                    // Pathが通っていれば'signtool'だけでいい
                    return (signtoolCache = 'signtool');
                }
            }
        }
        catch (e_19_1) { e_19 = { error: e_19_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
            }
            finally { if (e_19) throw e_19.error; }
        }
        // signtoolにパスが通っていなければレジストリからsigntoolのフルパスを取得
        try {
            var sdk = wshShell.RegRead('HKLM\\SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\CurrentInstallFolder');
            if (typeof sdk === 'string') {
                return (signtoolCache = fsoU.resolve(sdk, 'bin', 'signtool.exe'));
            }
        }
        catch (ex) {
            // レジストリからも取得に失敗したら例外
            throw new Error("signtoolが見つかりません。: " + ex.toString);
        }
    }
    /**
     * タイムスタンプを表示しないファイル名のパターン
     */
    var notimestamp = WScriptUtil.Arguments.Named('NoTimeStamp', function (param) { return (param && fsoU.wildcardToRegExp(param)) || undefined; });
    var shellappdesktopCache;
    function ShellappDesktop() {
        if (shellappdesktopCache !== undefined) {
            return shellappdesktopCache;
        }
        shellappdesktopCache = shellapp.NameSpace(0 /* ssfDESKTOP */);
        return shellappdesktopCache || (shellappdesktopCache = null);
    }
    function GetExtendedProperty(file, propertyName) {
        var desktop = ShellappDesktop();
        if (!desktop) {
            return '-';
        }
        var item = desktop.ParseName(file.Path);
        if (!item) {
            return '-';
        }
        var c = item.ExtendedProperty(propertyName);
        if (!c) {
            return '-';
        }
        return c;
    }
    /**
     * 表示されるファイルの情報
     */
    var COLUMNS = {
        // ビルド日時。ビルド日時の取得できないファイル、ディレクトリの場合は`-`
        build: function (file) { return GetBuildDate(file) || '-'; },
        // バージョンリソースの
        company: function (file) {
            return (fsoU.isFile(file) && GetExtendedProperty(file, 'System.Company')) || '-';
        },
        // バージョンリソースの著作権欄
        copyright: function (file) {
            return (fsoU.isFile(file) && GetExtendedProperty(file, 'System.Copyright')) ||
                '-';
        },
        // ファイルの存在するディレクトリ(ディレクトリの場合はそのディレクトリ自身)のフルパス。
        directory: function (file) { return (fsoU.isFolder(file) ? file : file.ParentFolder).Path; },
        // フルパス。
        fullpath: function (file) { return file.Path; },
        // 16進文字列で表記したファイルハッシュ。ディレクトリの場合は`-`
        hash: function (file) { return (fsoU.isFolder(file) ? '-' : FileHash(file.Path)); },
        // ファイルサイズ(桁区切り無し)、ディレクトリの場合は`-`
        length: function (file) { return (fsoU.isFolder(file) ? '-' : '' + file.Size); },
        // ファイル名、ディレクトリの場合は`-`。
        name: function (file) { return (fsoU.isFolder(file) ? '-' : file.Name); },
        // 相対パス。基準となるディレクトリは/BaseDirで指定する。
        relative: function (file) { return fsoU.relativePath(file.Path, basedir); },
        // directoryの相対パス版。基準となるディレクトリは/BaseDirで指定する。
        reldir: function (file) {
            return fsoU.relativePath((fsoU.isFolder(file) ? file : file.ParentFolder).Path, basedir);
        },
        // 電子署名済みの場合は署名者。署名に不備があれば不備の内容。ディレクトリの場合は`-`
        sign: function (file) { return (fsoU.isFile(file) ? checkSignature(file) : '-'); },
        // ファイルサイズ(3桁区切り)、ディレクトリの場合は`-`
        size: function (file) {
            return fsoU.isFolder(file)
                ? '-'
                : ('' + file.Size).replace(/\d(?=(?:\d{3})+$)/g, '$&,');
        },
        // タイムスタンプ
        timestamp: function (file) {
            return (notimestamp && notimestamp.test(file.Name) && '-') ||
                new Date(file.DateLastModified).toLocaleString();
        },
        // ファイルのバージョン。ディレクトリ、バージョンのないファイルは`-`
        version: function (file) { return (fsoU.isFolder(file) ? '-' : getFileVersion(file.Path)); }
    };
    // 各情報のエイリアス
    COLUMNS.n = COLUMNS.name;
    COLUMNS.d = COLUMNS.dir = COLUMNS.directory;
    COLUMNS.s = COLUMNS.size;
    COLUMNS.l = COLUMNS.len = COLUMNS.length;
    COLUMNS.v = COLUMNS.ver = COLUMNS.version;
    COLUMNS.f = COLUMNS.full = COLUMNS.fullpath;
    COLUMNS.r = COLUMNS.rel = COLUMNS.relative;
    COLUMNS.t = COLUMNS.time = COLUMNS.timestamp;
    COLUMNS.h = COLUMNS.hash;
    COLUMNS.g = COLUMNS.sign;
    COLUMNS.b = COLUMNS.build;
    COLUMNS.rd = COLUMNS.reldir;
    COLUMNS.cp = COLUMNS.company;
    COLUMNS.cr = COLUMNS.copyright;
    function column(name, file) {
        if (!name) {
            return;
        }
        name = name.toLowerCase();
        if (!(name in COLUMNS)) {
            return;
        }
        return COLUMNS[name](file);
    }
    function main() {
        var e_20, _a, e_21, _b;
        if (showHelp) {
            WScript.StdOut
                .Write("filevar.wsf: List information such as version and name of files and directories.\n\nUSAGE:\n  cscript //nologo filver.wsf /Help\n  cscript //nologo filver.wsf [/BaseDir:\"base\\directory\"] [/Format:\"Format for output\"] [/Output:\"output file\"] [path of files and directories...]\n\n/Help\n      Show this help.\n      Alias: /H /?\n/BaseDir:\"base\\directory\"\n      Specify the base directory of the specified path pattern.\n      If omitted, it is assumed that the current directory is specified.\n      Alias: /Base /B\n/Format:\"Format for output\"\n      Specify the format used for output of file and directory information.\n      If omitted, it is assumed that the '$r\\t$v' is specified\n      Alias: /F\n\n      $name\n        The name of the file or the directory.\n        Alias: $n\n      $directory\n        The path of the parent directory if it is a file, or its own path if it is a directory.\n        Alias: $dir $d\n      $size\n        The three-digit delimited file size, or '-' if it is a directory.\n        Alias: $s\n      $length\n        The file size(no delimited), or '-' if it is a directory.\n        Alias: $len $l\n      $version\n        The version of the file, or '-' if it is a file without a version or it is a directory.\n        Alias: $ver $v\n      $fullpath\n        The full path of the file or the directory.\n        Alias: $full $f\n      $relative\n        The relative path of the file or the directory.\n        Alias: $rel $r\n      $reldir\n        The relative path of the parent directory if it is a file, or its own relative path if it is a directory.\n        Alias: $rd\n      $timestamp\n        The full path of the file or the directory.\n        Alias: $time $t\n      $hash\n        The hash of the file, or '-' if it is a directory.\n        Alias: $h\n      $build\n        The date to build the content.\n        Alias: $b\n      $sign\n        The signer if the file is digitally signed, the error message if the signature it is incomplete. '-' if it is a directory.\n        Alias: $g\n      $company\n        The company in the file version resource, or '-' if it is a directory, or with out the version resource.\n        Alias: $cp\n      $copyright\n        The copyright in the file version resource, or '-' if it is a directory, or with out the version resource.\n        Alias: $cr\n/Output:\"output file\"\n      The file to output into.\n      If omitted, output into standard output.\n      Alias: /Out /O\n/Append\n      Specify it with /Output, then append output to file.\n/fileonly\n      Show information of files only.\n/directoryonly\n      Show information of directories only.\n      This parameter is ignored if `/fileonly` specified.\n/notimestamp:filename-pattern\n      Specify a pattern of file names that do not show timestamps.\n      If omitted, show timestamps of all files.\n/signtool:signtool_path\n      Specify the path to 'signtool.exe'.\n      If omitted, find signtool.exe from the current directory,\n      this script directory, and Windows SDK directory\n\npath of files and directories...\n      Files and directories for listing information. Wild cards can be used.\n      Example:\n      *.dll\n        DLL files in the current directory.\n      aaa?.dll\n        Dll files with only one letter after aaa.\n      *.{exe;dll;ocx}\n        EXE, DLL, OCX files in the current directory.\n      aaa\\**\\*.{exe;dll;ocx}\n        All EXE, DLL, OCX files under aaa directory.\n");
            return;
        }
        var args = __spread(Iterables.from(WScript.Arguments.Unnamed));
        if (args.length === 0) {
            args = ['**'];
        }
        try {
            // 各ファイル指定をワイルドカードとして展開
            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                var arg = args_1_1.value;
                var _loop_1 = function (file) {
                    if (ignored(file)) {
                        return "continue";
                    }
                    // 各ファイルの情報をフォーマットに従って出力
                    output.WriteLine(format.replace(/\$(?:\{(\w+)\}|(\w+))|\\(?:x([0-9A-Fa-f]{2})|(.))/g, function (whole, name1, name2, hex, ch) {
                        var value = column(name1 || name2, file);
                        if (typeof value === 'string') {
                            return value;
                        }
                        if (hex) {
                            return String.fromCharCode(parseInt(hex, 16));
                        }
                        if (ch) {
                            switch (ch) {
                                case 't':
                                    return '\t';
                                case 'r':
                                    return '\r';
                                case 'n':
                                    return '\n';
                            }
                            return ch;
                        }
                        return whole;
                    }));
                };
                try {
                    for (var _c = (e_21 = void 0, __values(fsoU.wildcard(arg, basedir))), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var file = _d.value;
                        _loop_1(file);
                    }
                }
                catch (e_21_1) { e_21 = { error: e_21_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c["return"])) _b.call(_c);
                    }
                    finally { if (e_21) throw e_21.error; }
                }
            }
        }
        catch (e_20_1) { e_20 = { error: e_20_1 }; }
        finally {
            try {
                if (args_1_1 && !args_1_1.done && (_a = args_1["return"])) _a.call(args_1);
            }
            finally { if (e_20) throw e_20.error; }
        }
    }
    filever.main = main;
})(filever || (filever = {}));
filever.main();
})();
]]></script>
</job>
