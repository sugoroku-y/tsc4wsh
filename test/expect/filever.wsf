<?xml version="1.0" encoding="utf-8" ?>
<job>
<object id="fso" progid="Scripting.FileSystemObject"/>
<object id="installer" progid="WindowsInstaller.Installer"/>
<object id="wshShell" progid="WScript.Shell"/>
<object id="shellapp" progid="Shell.Application"/>
<script language="JScript"><![CDATA[
'use strict';
this.__extends = function __extends(a, b) {
    if (a && b) {
      a.prototype = Object.create(b.prototype);
      a.prototype.constructor = a;
    }
};
function Symbol(description) {
  return Symbol.implement(description);
}
"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
(function () {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    var _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;
    (_a = Array.isArray) !== null && _a !== void 0 ? _a : (Array.isArray = function (obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    });
    (_b = Array.of) !== null && _b !== void 0 ? _b : (Array.of = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return args;
    });
    (_c = Array.from) !== null && _c !== void 0 ? _c : (Array.from = function from(arrayLike, mapFn, thisArg) {
        if (!mapFn || typeof mapFn !== 'function' || Object.prototype.toString.call(mapFn) !== '[object Function]') {
            mapFn = function (e) {
                return e;
            };
        }
        if (Array.isArray(arrayLike)) {
            return arrayLike.map(mapFn, thisArg);
        }
        if ('length' in arrayLike) {
            var length = +arrayLike.length || 0;
            var array_1 = [];
            for (var i_1 = 0; i_1 < length; ++i_1) {
                array_1[i_1] = mapFn.call(thisArg, arrayLike[i_1], i_1);
            }
            return array_1;
        }
        if (Symbol.iterator in arrayLike) {
            var array_2 = [];
            var iterator = arrayLike[Symbol.iterator]();
            var i_2 = 0;
            for (var result = void 0; !(result = iterator.next()).done;) {
                array_2.push(mapFn.call(thisArg, result.value, i_2++));
            }
            return array_2;
        }
        var array = [];
        var i = 0;
        for (var e = new Enumerator(arrayLike); !e.atEnd(); e.moveNext()) {
            array.push(mapFn.call(thisArg, e.item(), i++));
        }
        return array;
    });
    (_d = (_v = Array.prototype).some) !== null && _d !== void 0 ? _d : (_v.some = function some(callback, thisObj) {
        for (var i = 0; i < this.length; ++i) {
            if (!(i in this)) {
                continue;
            }
            if (callback.call(thisObj, this[i], i, this)) {
                return true;
            }
        }
        return false;
    });
    (_e = (_w = Array.prototype).every) !== null && _e !== void 0 ? _e : (_w.every = function every(callback, thisObj) {
        for (var i = 0; i < this.length; ++i) {
            if (!(i in this)) {
                continue;
            }
            if (!callback.call(thisObj, this[i], i, this)) {
                return false;
            }
        }
        return true;
    });
    (_f = (_x = Array.prototype).reduce) !== null && _f !== void 0 ? _f : (_x.reduce = function reduce(callback, initialValue) {
        var index = 0;
        var result = 1 < arguments.length ? initialValue : this[index++];
        for (; index < this.length; ++index) {
            if (!(index in this)) {
                continue;
            }
            result = callback(result, this[index], index, this);
        }
        return result;
    });
    (_g = (_y = Array.prototype).reduceRight) !== null && _g !== void 0 ? _g : (_y.reduceRight = function reduceRight(callback, initialValue) {
        var index = this.length;
        var result = 1 < arguments.length ? initialValue : this[--index];
        while (index-- > 0) {
            if (!(index in this)) {
                continue;
            }
            result = callback(result, this[index], index, this);
        }
        return result;
    });
    (_h = (_z = Array.prototype).forEach) !== null && _h !== void 0 ? _h : (_z.forEach = function forEach(callback, thisObj) {
        for (var index = 0; index < this.length; ++index) {
            if (!(index in this)) {
                continue;
            }
            callback.call(thisObj, this[index], index, this);
        }
    });
    (_j = (_0 = Array.prototype).filter) !== null && _j !== void 0 ? _j : (_0.filter = function filter(callback, thisObj) {
        var result = [];
        for (var index = 0; index < this.length; ++index) {
            if (!(index in this)) {
                continue;
            }
            var element = this[index];
            if (callback.call(thisObj, element, index, this)) {
                result.push(element);
            }
        }
        return result;
    });
    (_k = (_1 = Array.prototype).map) !== null && _k !== void 0 ? _k : (_1.map = function map(callback, thisObj) {
        var result = [];
        for (var index = 0; index < this.length; ++index) {
            if (!(index in this)) {
                continue;
            }
            result[index] = callback.call(thisObj, this[index], index, this);
        }
        return result;
    });
    function adjustIndex(value, length) {
        if (value === undefined) {
            return undefined;
        }
        if (value < 0) {
            value += length;
        }
        if (value < 0) {
            value = 0;
        }
        else if (value > length) {
            value = length;
        }
        return value;
    }
    (_l = (_2 = Array.prototype).copyWithin) !== null && _l !== void 0 ? _l : (_2.copyWithin = function copyWithin(_target, _start, _end) {
        var _a, _b, _c;
        var target = (_a = adjustIndex(_target, this.length)) !== null && _a !== void 0 ? _a : 0;
        var start = (_b = adjustIndex(_start, this.length)) !== null && _b !== void 0 ? _b : 0;
        if (target === start) {
            return this;
        }
        var end = (_c = adjustIndex(_end, this.length)) !== null && _c !== void 0 ? _c : this.length;
        if (target < start) {
            for (var s = start, d = target; s < end && d < this.length; ++s, ++d) {
                this[d] = this[s];
            }
        }
        else {
            for (var s = end - 1, d = target + (end - 1 - start); s >= start && d >= 0; --s, --d) {
                this[d] = this[s];
            }
        }
        return this;
    });
    (_m = (_3 = Array.prototype).fill) !== null && _m !== void 0 ? _m : (_3.fill = function fill(value, _start, _end) {
        var _a, _b;
        var start = (_a = adjustIndex(_start, this.length)) !== null && _a !== void 0 ? _a : 0;
        var end = (_b = adjustIndex(_end, this.length)) !== null && _b !== void 0 ? _b : this.length;
        for (var i = start; i < end; ++i) {
            this[i] = value;
        }
        return this;
    });
    (_o = (_4 = Array.prototype).find) !== null && _o !== void 0 ? _o : (_4.find = function find(pred, thisArg) {
        for (var i = 0; i < this.length; ++i) {
            if (!(i in this)) {
                continue;
            }
            var e = this[i];
            if (pred.call(thisArg, e, i, this)) {
                return e;
            }
        }
        return undefined;
    });
    (_p = (_5 = Array.prototype).findIndex) !== null && _p !== void 0 ? _p : (_5.findIndex = function findIndex(pred, thisArg) {
        for (var i = 0; i < this.length; ++i) {
            if (!(i in this)) {
                continue;
            }
            var e = this[i];
            if (pred.call(thisArg, e, i, this)) {
                return i;
            }
        }
        return -1;
    });
    (_q = (_6 = Array.prototype).includes) !== null && _q !== void 0 ? _q : (_6.includes = function includes(searchElement) {
        for (var i = 0; i < this.length; ++i) {
            if (!(i in this)) {
                continue;
            }
            if (this[i] === searchElement) {
                return true;
            }
        }
        return false;
    });
    (_r = (_7 = Array.prototype).indexOf) !== null && _r !== void 0 ? _r : (_7.indexOf = function indexOf(searchElement, _start) {
        var _a;
        var start = (_a = adjustIndex(_start, this.length)) !== null && _a !== void 0 ? _a : 0;
        for (var index = start; index < this.length; ++index) {
            if (this[index] === searchElement) {
                return index;
            }
        }
        return -1;
    });
    (_s = (_8 = Array.prototype).lastIndexOf) !== null && _s !== void 0 ? _s : (_8.lastIndexOf = function lastIndexOf(searchElement, _start) {
        var _a;
        var start = (_a = adjustIndex(_start, this.length)) !== null && _a !== void 0 ? _a : this.length - 1;
        for (var index = start; index >= 0; --index) {
            if (this[index] === searchElement) {
                return index;
            }
        }
        return -1;
    });
    (_t = (_9 = Array.prototype).entries) !== null && _t !== void 0 ? _t : (_9.entries = function entries() {
        var i;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < this.length)) return [3, 4];
                    return [4, [i, this[i]]];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    ++i;
                    return [3, 1];
                case 4: return [2];
            }
        });
    });
    (_u = (_10 = Array.prototype).keys) !== null && _u !== void 0 ? _u : (_10.keys = function keys() {
        var i;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < this.length)) return [3, 4];
                    return [4, i];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    ++i;
                    return [3, 1];
                case 4: return [2];
            }
        });
    });
})();
(function () {
    var _a;
    (_a = this.console) !== null && _a !== void 0 ? _a : (this.console = {
        log: function () {
            output(WScript.StdOut, arguments);
        },
        error: function () {
            output(WScript.StdErr, arguments);
        }
    });
    function output(stream, messages) {
        stream.WriteLine("[".concat(new Date().toLocaleTimeString(), "] ").concat(Array.from(messages, function (m) { return String(m); }).join(' ')));
    }
})();
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
(function () {
    var _a, _b;
    var _c;
    function format(template) {
        var values = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
        }
        return template.reduce(function (r, e, i) {
            var v = values[i - 1];
            var _a = __read(Array.isArray(v) ? v : [v, 2], 2), num = _a[0], digits = _a[1];
            return r + (digits ? num.toString().padStart(digits, '0') : num) + e;
        });
    }
    (_a = (_c = Date.prototype).toISOString) !== null && _a !== void 0 ? _a : (_c.toISOString = function toISOString() {
        if (isNaN(this.getTime())) {
            throw new Error('Invalid date');
        }
        return format(__makeTemplateObject(["", "-", "-", "T", ":", ":", ".", "Z"], ["", "-", "-", "T", ":", ":", ".", "Z"]), this.getUTCFullYear(), this.getUTCMonth() + 1, this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds(), [
            this.getUTCMilliseconds(),
            3,
        ]);
    });
    (_b = Date.now) !== null && _b !== void 0 ? _b : (Date.now = function now() {
        return new Date().getTime();
    });
})();
var _a, _b;
var _c, _d, _e, _f;
(function () {
    var symbols = {};
    this.Symbol.implement = function Symbol_implement(description) {
        var id = "Symbol@@".concat(description, "@@").concat(new Date().getTime(), "@@").concat(Math.random());
        symbols[id] = true;
        var symbol = {
            toString: function () {
                return id;
            },
            valueOf: function () {
                return description || '';
            }
        };
        return symbol;
    };
    this.Symbol.isSymbol = function (symbol) { return String(symbol) in symbols; };
    var registered = {};
    this.Symbol["for"] = function (key) { var _a; return ((_a = registered[key]) !== null && _a !== void 0 ? _a : (registered[key] = Symbol(key))); };
    this.Symbol.keyFor = function (sym) { var _a; return (_a = Object.entries(registered).find(function (_a) {
        var _b = __read(_a, 2), symbol = _b[1];
        return symbol === sym;
    })) === null || _a === void 0 ? void 0 : _a[0]; };
    this.Symbol.iterator = Symbol('iterator');
    this.Symbol.hasInstance = Symbol('hasInstance');
    this.Symbol.isConcatSpreadable = Symbol('isConcatSpreadable');
    this.Symbol.match = Symbol('match');
    this.Symbol.replace = Symbol('replace');
    this.Symbol.search = Symbol('search');
    this.Symbol.species = Symbol('species');
    this.Symbol.split = Symbol('split');
    this.Symbol.toPrimitive = Symbol('toPrimitive');
    this.Symbol.toStringTag = Symbol('toStringTag');
    this.Symbol.unscopables = Symbol('unscopables');
    this.Symbol.matchAll = Symbol('matchAll');
})();
(_a = (_c = Array.prototype)[_d = Symbol.iterator]) !== null && _a !== void 0 ? _a : (_c[_d] = function () {
    var i;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                i = 0;
                _a.label = 1;
            case 1:
                if (!(i < this.length)) return [3, 4];
                return [4, this[i]];
            case 2:
                _a.sent();
                _a.label = 3;
            case 3:
                ++i;
                return [3, 1];
            case 4: return [2];
        }
    });
});
(_b = (_e = String.prototype)[_f = Symbol.iterator]) !== null && _b !== void 0 ? _b : (_e[_f] = function () {
    var i;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                i = 0;
                _a.label = 1;
            case 1:
                if (!(i < this.length)) return [3, 4];
                return [4, this.charAt(i)];
            case 2:
                _a.sent();
                _a.label = 3;
            case 3:
                ++i;
                return [3, 1];
            case 4: return [2];
        }
    });
});
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
(function () {
    var _a, _b, _c, _d, _e, _f;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor',
    ];
    function keys(name, obj) {
        var _a, _b, _c, _i, prop, dontEnums_1, dontEnums_1_1, name_1, e_1_1;
        var e_1, _d;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    if (obj === null || obj === undefined) {
                        throw new TypeError("".concat(name, " called on non-object"));
                    }
                    switch (typeof obj) {
                        case 'object':
                            if (Symbol.isSymbol(obj)) {
                                return [2];
                            }
                        case 'function':
                            break;
                        default:
                            return [2];
                    }
                    _a = obj;
                    _b = [];
                    for (_c in _a)
                        _b.push(_c);
                    _i = 0;
                    _e.label = 1;
                case 1:
                    if (!(_i < _b.length)) return [3, 4];
                    _c = _b[_i];
                    if (!(_c in _a)) return [3, 3];
                    prop = _c;
                    if (Symbol.isSymbol(prop)) {
                        return [3, 3];
                    }
                    if (!hasOwnProperty.call(obj, prop)) {
                        return [3, 3];
                    }
                    return [4, prop];
                case 2:
                    _e.sent();
                    _e.label = 3;
                case 3:
                    _i++;
                    return [3, 1];
                case 4:
                    _e.trys.push([4, 9, 10, 11]);
                    dontEnums_1 = __values(dontEnums), dontEnums_1_1 = dontEnums_1.next();
                    _e.label = 5;
                case 5:
                    if (!!dontEnums_1_1.done) return [3, 8];
                    name_1 = dontEnums_1_1.value;
                    if (!hasOwnProperty.call(obj, name_1)) {
                        return [3, 7];
                    }
                    return [4, name_1];
                case 6:
                    _e.sent();
                    _e.label = 7;
                case 7:
                    dontEnums_1_1 = dontEnums_1.next();
                    return [3, 5];
                case 8: return [3, 11];
                case 9:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 11];
                case 10:
                    try {
                        if (dontEnums_1_1 && !dontEnums_1_1.done && (_d = dontEnums_1["return"])) _d.call(dontEnums_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7];
                case 11: return [2];
            }
        });
    }
    function map(iterable, pred) {
        var iterable_1, iterable_1_1, e, e_2_1;
        var e_2, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 5, 6, 7]);
                    iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next();
                    _b.label = 1;
                case 1:
                    if (!!iterable_1_1.done) return [3, 4];
                    e = iterable_1_1.value;
                    return [4, pred(e)];
                case 2:
                    _b.sent();
                    _b.label = 3;
                case 3:
                    iterable_1_1 = iterable_1.next();
                    return [3, 1];
                case 4: return [3, 7];
                case 5:
                    e_2_1 = _b.sent();
                    e_2 = { error: e_2_1 };
                    return [3, 7];
                case 6:
                    try {
                        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1["return"])) _a.call(iterable_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                    return [7];
                case 7: return [2];
            }
        });
    }
    (_a = Object.keys) !== null && _a !== void 0 ? _a : (Object.keys = function (obj) { return __spreadArray([], __read(keys('Object.keys', obj)), false); });
    (_b = Object.entries) !== null && _b !== void 0 ? _b : (Object.entries = function (obj) { return __spreadArray([], __read(map(keys('Object.entries', obj), function (name) { return [name, obj[name]]; })), false); });
    (_c = Object.values) !== null && _c !== void 0 ? _c : (Object.values = function (obj) { return __spreadArray([], __read(map(keys('Object.values', obj), function (name) { return obj[name]; })), false); });
    (_d = Object.fromEntries) !== null && _d !== void 0 ? _d : (Object.fromEntries = function (entries) {
        return entries.reduce(function (r, _a) {
            var _b = __read(_a, 2), name = _b[0], value = _b[1];
            return ((r[name] = value), r);
        }, {});
    });
    (_e = Object.create) !== null && _e !== void 0 ? _e : (Object.create = function (proto, propertiesObject) {
        if (typeof proto !== 'object' && typeof proto !== 'function') {
            throw new TypeError("Object prototype may only be an Object: ".concat(proto));
        }
        if (proto === null) {
            throw new Error("This Object.create is a shim and doesn't support 'null' as the first argument.");
        }
        if (propertiesObject !== undefined) {
            throw new Error("This Object.create is a shim and doesn't support a second argument.");
        }
        var F = (function () {
            function F() {
            }
            return F;
        }());
        F.prototype = proto;
        if (typeof proto === 'function') {
            var originalToString_1 = proto.toString;
            proto.toString = function () { return originalToString_1.call(proto); };
        }
        return new F();
    });
    (_f = Object.assign) !== null && _f !== void 0 ? _f : (Object.assign = function (target) {
        var e_3, _a, e_4, _b;
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        if (target == null) {
            throw new TypeError('Cannot convert null or undefined to object');
        }
        var to = new Object(target);
        try {
            for (var sources_1 = __values(sources), sources_1_1 = sources_1.next(); !sources_1_1.done; sources_1_1 = sources_1.next()) {
                var source = sources_1_1.value;
                try {
                    for (var _c = (e_4 = void 0, __values(Object.keys(source))), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var name = _d.value;
                        to[name] = source[name];
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c["return"])) _b.call(_c);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (sources_1_1 && !sources_1_1.done && (_a = sources_1["return"])) _a.call(sources_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return to;
    });
})();
(function () {
    var ENQUOTE = {
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r'
    };
    var DEQUOTE = Object.fromEntries(Object.entries(ENQUOTE).map(function (_a) {
        var _b = __read(_a, 2), ch = _b[0], enquote = _b[1];
        return [enquote, ch];
    }));
    var ENQUOTE_RE = /[\x00-\x1f\\"]/g;
    var DEQUOTE_RE = /\\(?:u([0-9A-Fa-f]{4})|.)/g;
    var ACCEPT_TYPES = {
        boolean: true,
        number: true,
        object: true,
        string: true,
        undefined: true
    };
    this.JSON = this.JSON || {};
    function enquote(str) {
        return "\"".concat(str.replace(ENQUOTE_RE, function (ch) {
            return '\\"'.includes(ch)
                ? "\\".concat(ch)
                : ch in ENQUOTE
                    ? ENQUOTE[ch]
                    : '\\u' + ch.charCodeAt(0).toString(16).padStart(4, '0');
        }), "\"");
    }
    function dequote(quoted) {
        return quoted
            .slice(1, -1)
            .replace(DEQUOTE_RE, function (enquote, hex) {
            return hex ? String.fromCharCode(parseInt(hex, 16)) : enquote in DEQUOTE ? DEQUOTE[enquote] : enquote.charAt(1);
        });
    }
    var cache = {};
    var Parser = (function () {
        function Parser(str) {
            this.str = str;
            this.index = 0;
        }
        Parser.prototype.parse = function (reviewer) {
            var value = this.parseValue();
            this.skipWS();
            if (this.isLeft()) {
                this.failedParsing();
            }
            if (!reviewer) {
                return value;
            }
            return (function recursive(key, subvalue) {
                var e_5, _a;
                if (subvalue && typeof subvalue === 'object') {
                    try {
                        for (var _b = __values(Object.entries(subvalue)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var _d = __read(_c.value, 2), k = _d[0], v = _d[1];
                            subvalue[k] = recursive(k, v);
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                }
                return reviewer(key, subvalue);
            })('', value);
        };
        Parser.prototype.stickyMatch = function (pattern) {
            var re = cache[pattern] || (cache[pattern] = new RegExp("(?:".concat(pattern, ")|(?=([\\s\\S]))"), 'g'));
            re.lastIndex = this.index;
            var match = re.exec(this.str);
            if (!match || match[match.length - 1]) {
                return undefined;
            }
            this.index += match[0].length;
            return match;
        };
        Parser.prototype.failedParsing = function () {
            if (!this.isLeft()) {
                throw new Error("Unexpected the end of string");
            }
            var re = /[^\r\n]*(?:\r?\n|\r|$)/g;
            var _a = __read([0, 0], 2), line = _a[0], bol = _a[1];
            while (true) {
                var match = re.exec(this.str);
                if (!match) {
                    break;
                }
                var eol = match.index + match[0].length;
                if (eol >= this.index) {
                    break;
                }
                ++line;
                bol = eol;
            }
            var column = this.index - bol;
            throw new Error("unexpected: ".concat(this.str.substr(this.index, 10), " at line: ").concat(line, ", column: ").concat(column));
        };
        Parser.prototype.skipWS = function () {
            this.stickyMatch("\\s+");
        };
        Parser.prototype.scanOne = function (candidates, noThrow) {
            this.skipWS();
            if (!this.isLeft()) {
                return this.failedParsing();
            }
            var ch = this.str.charAt(this.index);
            if (candidates.indexOf(ch) < 0) {
                if (noThrow) {
                    return undefined;
                }
                return this.failedParsing();
            }
            ++this.index;
            return ch;
        };
        Parser.prototype.parseWord = function (pattern, value) {
            this.skipWS();
            return this.stickyMatch(pattern) ? value : this.failedParsing();
        };
        Parser.prototype.parseNumber = function () {
            this.skipWS();
            var match = this.stickyMatch("-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[Ee][-+]?\\d+)?\\b");
            return match ? +match[0] : this.failedParsing();
        };
        Parser.prototype.parseString = function () {
            this.skipWS();
            var match = this.stickyMatch("\"[^\\\\\"]*(?:\\\\.[^\\\\\"]*)*\"");
            return match ? dequote(match[0]) : this.failedParsing();
        };
        Parser.prototype.parseSequence = function (terminater, initialValue, continuousProc) {
            ++this.index;
            var value = initialValue;
            if (!this.scanOne(terminater, true)) {
                var termsep = terminater + ',';
                do {
                    continuousProc(value);
                } while (this.scanOne(termsep) !== terminater);
            }
            return value;
        };
        Parser.prototype.parseValue = function () {
            var _this = this;
            this.skipWS();
            switch (this.str.charAt(this.index)) {
                case 'n':
                    return this.parseWord("null\\b", null);
                case 't':
                    return this.parseWord("true\\b", true);
                case 'f':
                    return this.parseWord("false\\b", false);
                case '-':
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    return this.parseNumber();
                case '"':
                    return this.parseString();
                case '[':
                    return this.parseSequence(']', [], function (arr) {
                        arr.push(_this.parseValue());
                    });
                case '{':
                    return this.parseSequence('}', {}, function (obj) {
                        _this.skipWS();
                        var name = _this.parseString();
                        _this.scanOne(':');
                        obj[name] = _this.parseValue();
                    });
            }
            this.failedParsing();
        };
        Parser.prototype.isLeft = function () {
            return this.index < this.str.length;
        };
        return Parser;
    }());
    this.JSON.parse =
        this.JSON.parse ||
            function parse(str, reviewer) {
                return new Parser(str).parse(reviewer);
            };
    this.JSON.stringify =
        this.JSON.stringify ||
            function stringify(value, replacer, space) {
                var validKeys = Array.isArray(replacer) ? replacer : undefined;
                var p = typeof replacer === 'function' ? replacer : undefined;
                var indentUnit = typeof space === 'number' ? ' '.repeat(space) : typeof space === 'string' ? space : '';
                var indent = function (depth) { return (indentUnit && '\n' + indentUnit.repeat(depth)) || ''; };
                return (function sub(v, depth) {
                    switch (v) {
                        case undefined:
                        case null:
                            return 'null';
                        case true:
                            return 'true';
                        case false:
                            return 'false';
                    }
                    var handlers = {
                        number: function (n) { return (isNaN(n) ? 'null' : '' + n); },
                        string: function (s) { return enquote(s); },
                        object: function (o) {
                            if (typeof o.toJSON === 'function') {
                                var json = o.toJSON();
                                if (json !== o) {
                                    return sub(json, depth);
                                }
                            }
                            if (Array.isArray(o)) {
                                if (o.length === 0) {
                                    return '[]';
                                }
                                return ('[' +
                                    indent(depth + 1) +
                                    o
                                        .map(function (json, i) {
                                        return sub(p ? p('' + i, json) : json, depth + 1) ||
                                            'null';
                                    })
                                        .join(',' + indent(depth + 1)) +
                                    indent(depth) +
                                    ']');
                            }
                            var entries = Object.entries(o)
                                .filter(function (_a) {
                                var _b = __read(_a, 2), k = _b[0], sv = _b[1];
                                return ACCEPT_TYPES[typeof sv] && (!validKeys || validKeys.includes(k));
                            })
                                .map(function (_a) {
                                var _b = __read(_a, 2), k = _b[0], sv = _b[1];
                                return [enquote(k), sub(p ? p(k, sv) : sv, depth + 1)];
                            })
                                .filter(function (_a) {
                                var _b = __read(_a, 2), sv = _b[1];
                                return !!sv;
                            })
                                .map(function (_a) {
                                var _b = __read(_a, 2), k = _b[0], sv = _b[1];
                                return "".concat(k, ":").concat(space ? ' ' : '').concat(sv);
                            });
                            if (entries.length === 0) {
                                return '{}';
                            }
                            return '{' + indent(depth + 1) + entries.join(',' + indent(depth + 1)) + indent(depth) + '}';
                        }
                    };
                    var handler = handlers[typeof v];
                    return handler ? handler(v) : '';
                })(value, 0);
            };
})();
(function () {
    var _a, _b, _c, _d, _e, _f;
    this.Number.EPSILON = Number.EPSILON || 2.2204460492503130808472633361816e-16;
    this.Number.MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    this.Number.MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    (_a = Number.isFinite) !== null && _a !== void 0 ? _a : (Number.isFinite = (function (o) {
        return typeof o === 'number' &&
            o !== Infinity &&
            o !== -Infinity &&
            !isNaN(o);
    }));
    (_b = Number.isInteger) !== null && _b !== void 0 ? _b : (Number.isInteger = (function (o) {
        return typeof o === 'number' && Math.ceil(o) === o;
    }));
    (_c = Number.isNaN) !== null && _c !== void 0 ? _c : (Number.isNaN = function (o) { return typeof o === 'number' && isNaN(o); });
    (_d = Number.isSafeInteger) !== null && _d !== void 0 ? _d : (Number.isSafeInteger = (function (o) {
        return Number.isInteger(o) &&
            o <= Number.MAX_SAFE_INTEGER &&
            o >= Number.MIN_SAFE_INTEGER;
    }));
    (_e = Number.parseFloat) !== null && _e !== void 0 ? _e : (Number.parseFloat = parseFloat);
    (_f = Number.parseInt) !== null && _f !== void 0 ? _f : (Number.parseInt = parseInt);
})();
(function () {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    var _j, _k, _l, _m, _o, _p, _q, _r;
    (_a = (_j = String.prototype).repeat) !== null && _a !== void 0 ? _a : (_j.repeat = function repeat(count) {
        if (!count) {
            return '';
        }
        if (count < 0) {
            throw new Error('repeat count must be non-negative');
        }
        if (count === Infinity) {
            throw new Error('repeat count must be less than infinity');
        }
        return Array(count).fill(this).join('');
    });
    String.prototype.substr = function substr(start, length) {
        if (length !== undefined && (!length || length < 0)) {
            return '';
        }
        return this.slice(start, length !== undefined ? (start < 0 && start + length >= 0 ? undefined : start + length) : this.length);
    };
    (_b = (_k = String.prototype).padStart) !== null && _b !== void 0 ? _b : (_k.padStart = function padStart(length, paddings) {
        var count = length - this.length;
        if (count <= 0) {
            return "".concat(this);
        }
        paddings !== null && paddings !== void 0 ? paddings : (paddings = ' ');
        return paddings.repeat((length / paddings.length + 1) | 0).slice(0, count) + this;
    });
    (_c = (_l = String.prototype).padEnd) !== null && _c !== void 0 ? _c : (_l.padEnd = function padEnd(length, paddings) {
        var count = length - this.length;
        if (count <= 0) {
            return "".concat(this);
        }
        paddings !== null && paddings !== void 0 ? paddings : (paddings = ' ');
        return this + paddings.repeat((length / paddings.length + 1) | 0).slice(0, count);
    });
    (_d = (_m = String.prototype).startsWith) !== null && _d !== void 0 ? _d : (_m.startsWith = function startsWith(searchString, position) {
        if (!position) {
            return this.lastIndexOf(searchString, 0) === 0;
        }
        return this.slice(position, position + searchString.length) === searchString;
    });
    (_e = (_o = String.prototype).endsWith) !== null && _e !== void 0 ? _e : (_o.endsWith = function endsWith(searchString, position) {
        if (!position) {
            var pos_1 = this.length - searchString.length;
            return this.indexOf(searchString, pos_1) === pos_1;
        }
        var pos = position - searchString.length;
        return pos >= 0 && this.slice(pos, position) === searchString;
    });
    (_f = (_p = String.prototype).trim) !== null && _f !== void 0 ? _f : (_p.trim = function trim() {
        return this.replace(/^\s+|\s+$/g, '');
    });
    (_g = (_q = String.prototype).includes) !== null && _g !== void 0 ? _g : (_q.includes = function includes(searchString, position) {
        return this.indexOf(searchString, position) >= 0;
    });
    var original_split = String.prototype.split;
    String.prototype.split = function split(separator, limit) {
        var e_6, _a;
        var str = '' + this;
        if (typeof separator === 'string') {
            return original_split.call(str, separator, limit);
        }
        if (!(separator instanceof RegExp)) {
            return separator[Symbol.split](str, limit);
        }
        var flags = "g".concat(separator.ignoreCase ? 'i' : '').concat(separator.multiline ? 'm' : '');
        var pattern = new RegExp(separator.source, flags);
        var index = 0;
        var result = [];
        try {
            for (var _b = __values(this.matchAll(pattern)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var match = _c.value;
                if (index === match.index && match[0].length === 0)
                    continue;
                result.push.apply(result, __spreadArray([str.slice(index, match.index)], __read(match.slice(1)), false));
                index = match.index + match[0].length;
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
        result.push(str.slice(index));
        return result;
    };
    (_h = (_r = String.prototype).matchAll) !== null && _h !== void 0 ? _h : (_r.matchAll = function matchAll(_pattern) {
        if (!_pattern.global) {
            throw new Error("matchAll with a non-global RegExp");
        }
        var flags = "g".concat(_pattern.ignoreCase ? 'i' : '').concat(_pattern.multiline ? 'm' : '');
        return function (pattern) {
            var match;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!!(match = pattern.exec(this))) return [3, 2];
                        return [4, match];
                    case 1:
                        _a.sent();
                        return [3, 0];
                    case 2: return [2];
                }
            });
        }.call(this, new RegExp(_pattern.source, flags));
    });
})();


(function () {
'use strict';
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function x(a) {
    if (typeof a === 'function') {
        a = a();
        a;
    }
    else {
        a;
    }
    a;
}
var Iterables;
(function (Iterables) {
    /**
     * Iterables のメソッドをメンバに持つIterable。
     *
     * @class IterableEx
     * @implements {I<T>}
     * @template T
     */
    var IterableEx = /** @class */ (function () {
        function IterableEx(param) {
            var p = typeof param === 'function' ? param() : param;
            this[Symbol.iterator] = function () { return p[Symbol.iterator](); };
        }
        IterableEx.prototype.forEach = function (callback) {
            forEach(this, callback);
        };
        IterableEx.prototype.some = function (callback) {
            return some(this, callback);
        };
        IterableEx.prototype.every = function (callback) {
            return every(this, callback);
        };
        IterableEx.prototype.filter = function (callback) {
            return filter(this, callback);
        };
        IterableEx.prototype.map = function (callback) {
            return map(this, callback);
        };
        IterableEx.prototype.reduce = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return reduce.apply(void 0, __spreadArray([this], __read(args), false));
        };
        IterableEx.prototype.join = function (sep) {
            return join(this, sep);
        };
        IterableEx.prototype.concat = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return concat.apply(void 0, __spreadArray([this], __read(args), false));
        };
        return IterableEx;
    }());
    Symbol.iterator;
    /**
     * Iterableの返す各要素に対してコールバックを呼び出す。
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {(e: T, i: number, x: X) => any} callback 引数で指定したIterableの各要素を渡して呼び出すコールバックを指定する。
     */
    function forEach(x, callback) {
        var e_1, _a;
        var i = 0;
        try {
            for (var _b = __values(x), _c = _b.next(); !_c.done; _c = _b.next()) {
                var e = _c.value;
                callback(e, i++, x);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    Iterables.forEach = forEach;
    /**
     * Iterableの返す各要素に対してコールバックを呼び出し、一つでもtruthyな値を返すものがあればtrueを返す。
     *
     * truthyな値を返す要素が見つかった時点で各要素へのコールバックの呼び出しを中断する。
     *
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {(e: T, i: number, x: X) => boolean} callback 引数で指定したIterableの各要素を渡して呼び出すコールバックを指定する。
     * @returns {boolean} Iterableの返す各要素に対してコールバックを呼び出し、一つでもtruthyな値を返すものがあればtrueを返す。いずれの要素もfalsyな値を返した場合はfalseを返す。
     */
    function some(x, callback) {
        var e_2, _a;
        var i = 0;
        try {
            for (var _b = __values(x), _c = _b.next(); !_c.done; _c = _b.next()) {
                var e = _c.value;
                if (callback(e, i++, x)) {
                    return true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return false;
    }
    Iterables.some = some;
    /**
     * Iterableの返す各要素に対してコールバックを呼び出し、一つでもfalsyな値を返すものがあればfalseを返す。
     *
     * falsyな値を返す要素が見つかった時点で各要素へのコールバックの呼び出しを中断する。
     *
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {(e: T, i: number, x: X) => boolean} callback 引数で指定したIterableの各要素を渡して呼び出すコールバックを指定する。
     * @returns {boolean} Iterableの返す各要素に対してコールバックを呼び出し、一つでもfalsyな値を返すものがあればfalseを返す。いずれの要素もtruthyな値を返した場合はtrueを返す。
     */
    function every(x, callback) {
        var e_3, _a;
        var i = 0;
        try {
            for (var _b = __values(x), _c = _b.next(); !_c.done; _c = _b.next()) {
                var e = _c.value;
                if (!callback(e, i++, x)) {
                    return false;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return true;
    }
    Iterables.every = every;
    function filter(x, callback) {
        return new IterableEx(function () {
            var i, _a, _b, e, e_4_1;
            var e_4, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        i = 0;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, 7, 8]);
                        _a = __values(x), _b = _a.next();
                        _d.label = 2;
                    case 2:
                        if (!!_b.done) return [3 /*break*/, 5];
                        e = _b.value;
                        if (!callback(e, i++, x)) return [3 /*break*/, 4];
                        return [4 /*yield*/, e];
                    case 3:
                        _d.sent();
                        _d.label = 4;
                    case 4:
                        _b = _a.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_4_1 = _d.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                        }
                        finally { if (e_4) throw e_4.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    }
    Iterables.filter = filter;
    /**
     * Iterableの返す各要素に対してコールバックを呼び出し、コールバックの返す値を要素とするIterableExを生成する。
     *
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @template S この関数が返すIterableExの要素の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {(e: T, i: number, x: X) => S} callback 引数で指定したIterableの各要素を渡して呼び出すコールバックを指定する。
     * @returns {IterableEx<T>} Iterableの返す各要素に対してコールバックを呼び出し、コールバックの返す値を要素とするIterableExを生成して返す。
     */
    function map(x, callback) {
        return new IterableEx(function () {
            var i, _a, _b, e, e_5_1;
            var e_5, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        i = 0;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, 7, 8]);
                        _a = __values(x), _b = _a.next();
                        _d.label = 2;
                    case 2:
                        if (!!_b.done) return [3 /*break*/, 5];
                        e = _b.value;
                        return [4 /*yield*/, callback(e, i++, x)];
                    case 3:
                        _d.sent();
                        _d.label = 4;
                    case 4:
                        _b = _a.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_5_1 = _d.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                        }
                        finally { if (e_5) throw e_5.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    }
    Iterables.map = map;
    function reduce(x, callback, initialValue) {
        var _a, e_6, _b;
        var iterable = x;
        var initialIndex = 0;
        if (arguments.length <= 2) {
            var itr_1 = iterable[Symbol.iterator]();
            var ir = itr_1.next();
            if (ir.done) {
                throw new Error('Reduce of empty Iterable with no initial value');
            }
            initialIndex = 1;
            iterable = (_a = {},
                _a[Symbol.iterator] = function () {
                    return itr_1;
                },
                _a);
            initialValue = ir.value; // arguments.length <= 2 なら ir.value is S(=T)
        }
        var r = initialValue; // arguments.length > 2 なら initialValue is S(not nullish)
        var i = initialIndex;
        try {
            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                var e = iterable_1_1.value;
                r = callback(r, e, i++, x);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (iterable_1_1 && !iterable_1_1.done && (_b = iterable_1["return"])) _b.call(iterable_1);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return r;
    }
    Iterables.reduce = reduce;
    /**
     * Iterableの返す各要素を文字列に変換し、結合する。
     *
     * @export
     * @template T 引数で指定したIterableが返す要素の型を指定する。
     * @template X 引数で指定したIterableの実際の型を指定する。
     * @param {X} x コールバックを呼び出す要素を返すIterableを指定する。
     * @param {string} sep 結合する際に各要素間に挿入する文字列を指定する。
     * @returns {string} Iterableの返す各要素を文字列に変換し、結合した文字列を返す。
     */
    function join(x, sep) {
        var _a;
        sep !== null && sep !== void 0 ? sep : (sep = ',');
        var itr = x[Symbol.iterator]();
        var _b = itr.next(), value = _b.value, done = _b.done;
        if (done) {
            return '';
        }
        var result = String(value);
        while (((_a = itr.next(), value = _a.value, done = _a.done), !done)) {
            result += sep;
            result += String(value);
        }
        return result;
    }
    Iterables.join = join;
    /**
     * 引数に指定した全てのIterableを結合したIterableExを生成する。
     *
     * @export
     * @template T 全引数の型を指定する。
     * @param {...T} generators Iterableの配列を指定する
     * @returns {Ex<T extends Array<I<infer R>> ? R : never>} 引数に指定した全てのIterableを結合したIterableExを生成して返す。
     */
    function concat() {
        var generators = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            generators[_i] = arguments[_i];
        }
        return new IterableEx(function () {
            var generators_1, generators_1_1, generator, e_7_1;
            var e_7, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, 6, 7]);
                        generators_1 = __values(generators), generators_1_1 = generators_1.next();
                        _b.label = 1;
                    case 1:
                        if (!!generators_1_1.done) return [3 /*break*/, 4];
                        generator = generators_1_1.value;
                        return [5 /*yield**/, __values(generator)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        generators_1_1 = generators_1.next();
                        return [3 /*break*/, 1];
                    case 4: return [3 /*break*/, 7];
                    case 5:
                        e_7_1 = _b.sent();
                        e_7 = { error: e_7_1 };
                        return [3 /*break*/, 7];
                    case 6:
                        try {
                            if (generators_1_1 && !generators_1_1.done && (_a = generators_1["return"])) _a.call(generators_1);
                        }
                        finally { if (e_7) throw e_7.error; }
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    }
    Iterables.concat = concat;
    function isIterable(collection) {
        return typeof collection[Symbol.iterator] === 'function';
    }
    function from(collection) {
        // もともとIterableExの場合はそのまま返す
        if (isIterableEx(collection)) {
            return collection;
        }
        return new IterableEx(
        // Iterableの場合はIterableExのコンストラクタに引数として渡す
        isIterable(collection)
            ? collection
            : // それ以外はEnumeratorを生成してみてコンストラクタに引数として渡す
                function () {
                    var e;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                e = new Enumerator(collection);
                                _a.label = 1;
                            case 1:
                                if (!!e.atEnd()) return [3 /*break*/, 4];
                                return [4 /*yield*/, e.item()];
                            case 2:
                                _a.sent();
                                _a.label = 3;
                            case 3:
                                e.moveNext();
                                return [3 /*break*/, 1];
                            case 4: return [2 /*return*/];
                        }
                    });
                });
    }
    Iterables.from = from;
    function of() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return from(args);
    }
    Iterables.of = of;
    function max(itr) {
        return reduce(itr, function (mx, e) { return (mx < e ? e : mx); });
    }
    Iterables.max = max;
    function min(itr) {
        return reduce(itr, function (mn, e) { return (mn > e ? e : mn); });
    }
    Iterables.min = min;
    /**
     * IterableExかどうかを判別する
     * @export
     * @param {*} x IterableExかどうかを判別するオブジェクト
     * @returns {x is IterableEx<any>} gがIterableExであれば真を返す。
     */
    function isIterableEx(x) {
        return x && x instanceof IterableEx;
    }
})(Iterables || (Iterables = {}));
/// <reference types="dom3" />
/// <reference types="iterables" />
var WScriptUtil;
(function (WScriptUtil) {
    var Arguments;
    (function (Arguments) {
        function Named(params, convArg) {
            var _a = __read(typeof params === 'string' || Array.isArray(params) ? [params, convArg] : [params.key, params.conv], 2), key = _a[0], conv = _a[1];
            var keys = Array.isArray(key) ? key : [key];
            var value = (function () {
                var e_8, _a;
                try {
                    for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                        var k = keys_1_1.value;
                        if (WScript.Arguments.Named.Exists(k)) {
                            return WScript.Arguments.Named(k);
                        }
                    }
                }
                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                finally {
                    try {
                        if (keys_1_1 && !keys_1_1.done && (_a = keys_1["return"])) _a.call(keys_1);
                    }
                    finally { if (e_8) throw e_8.error; }
                }
                return undefined;
            })();
            return conv ? conv(value) : value;
        }
        Arguments.Named = Named;
        function Switch(keys) {
            var e_9, _a;
            try {
                for (var _b = __values(Array.isArray(keys) ? keys : [keys]), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (WScript.Arguments.Named.Exists(key)) {
                        return true;
                    }
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
                }
                finally { if (e_9) throw e_9.error; }
            }
            return false;
        }
        Arguments.Switch = Switch;
        function Unnamed() {
            return Iterables.from(WScript.Arguments.Unnamed);
        }
        Arguments.Unnamed = Unnamed;
    })(Arguments = WScriptUtil.Arguments || (WScriptUtil.Arguments = {}));
    function validateParameters() {
        var e_10, _a;
        if (WScript.Arguments.Named.Exists('?') || WScript.Arguments.Named.Exists('help')) {
            WScript.Arguments.ShowUsage();
            return WScript.Quit(0);
        }
        var doc = WScript.CreateObject('MSXML2.DOMDocument.6.0');
        doc.load(WScript.ScriptFullName);
        var hasError = false;
        try {
            for (var _b = __values(Iterables.from(doc.selectNodes('/job/runtime/named'))), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                if (node.nodeType !== 1 /* DOM3.NodeType.ELEMENT_NODE */) {
                    continue;
                }
                var name = node.getAttribute('name');
                if (!name) {
                    continue;
                }
                var required = node.getAttribute('required') === 'true';
                if (!WScript.Arguments.Named.Exists(name)) {
                    if (required) {
                        WScript.Echo(''.concat(name, ' は必須パラメータです。'));
                        hasError = true;
                    }
                    continue;
                }
                var value = WScript.Arguments.Named(name);
                switch (node.getAttribute('type')) {
                    case 'string':
                        if (typeof value !== 'string') {
                            WScript.Echo(''.concat(name, ' には文字列を指定(/').concat(name, ':文字列)してください。'));
                            hasError = true;
                            continue;
                        }
                        break;
                    case 'boolean':
                        if (typeof value !== 'boolean') {
                            WScript.Echo(''.concat(name, ' にはオン(/').concat(name, '+)、もしくはオフ(/').concat(name, '-)を指定してください。'));
                            hasError = true;
                            continue;
                        }
                        break;
                    default:
                        // case 'simple':
                        if (typeof value !== 'undefined') {
                            WScript.Echo(''.concat(name, ' にはパラメータだけ(/').concat(name, ')を指定してください。'));
                            hasError = true;
                            continue;
                        }
                        break;
                }
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
            }
            finally { if (e_10) throw e_10.error; }
        }
        var unnamedElement = doc.selectSingleNode('/job/runtime/unnamed');
        if (unnamedElement && unnamedElement.nodeType === 1 /* DOM3.NodeType.ELEMENT_NODE */) {
            var isMany = unnamedElement.getAttribute('many') === 'true';
            var required = (function (value) { return (!value ? 0 : value === 'true' ? 1 : value === 'false' ? 0 : +value); })(unnamedElement.getAttribute('required'));
            if (WScript.Arguments.Unnamed.length < required) {
                WScript.Echo('パラメータが不足しています(必要数: '.concat(required, '})。'));
                hasError = true;
            }
            else if (WScript.Arguments.Unnamed.length > required && !isMany) {
                WScript.Echo(required > 0 ? 'パラメータが多過ぎます(必要数: '.concat(required, '})。') : 'パラメータは不要です。');
                hasError = true;
            }
        }
        if (hasError) {
            return WScript.Quit(1);
        }
    }
    WScriptUtil.validateParameters = validateParameters;
})(WScriptUtil || (WScriptUtil = {}));
/// <reference types="iterables" />
var Scripting;
(function (Scripting) {
    var FileSystemObject;
    (function (FileSystemObject) {
        var Utils;
        (function (Utils) {
            function isFolder(f) {
                return 'Files' in f;
            }
            Utils.isFolder = isFolder;
            function isFile(f) {
                return !isFolder(f);
            }
            Utils.isFile = isFile;
            function sort(array) {
                return array.sort(function (a, b) {
                    var aa = a.Name.toUpperCase();
                    var bb = b.Name.toUpperCase();
                    return aa === bb ? 0 : aa < bb ? -1 : 1;
                });
            }
            function files(folder) {
                return sort(__spreadArray([], __read(Iterables.from(folder.Files)), false));
            }
            Utils.files = files;
            function subFolders(folder) {
                return sort(__spreadArray([], __read(Iterables.from(folder.SubFolders)), false));
            }
            Utils.subFolders = subFolders;
            function filesAndSubFolders(folder) {
                return sort(__spreadArray(__spreadArray([], __read(Iterables.from(folder.Files)), false), __read(Iterables.from(folder.SubFolders)), false));
            }
            Utils.filesAndSubFolders = filesAndSubFolders;
            function getItem(path) {
                if (fso.FileExists(path)) {
                    return fso.GetFile(path);
                }
                if (fso.FolderExists(path)) {
                    return fso.GetFolder(path);
                }
                return undefined;
            }
            Utils.getItem = getItem;
            function error(message) {
                throw new Error(message);
            }
            function splitPath(path) {
                return __spreadArray([], __read(path.matchAll(/^((?:[A-Z]:|\\{2}[^\\]+\\[^\\]+)?\\)\\*|([^\\]+\\)\\*|([^\\]+)$|[\s\S]/gi)), false).map(function (_a) {
                    var $1 = _a[1], $2 = _a[2], $3 = _a[3], index = _a.index;
                    return $1 || $2 || $3 || error('不正なパス: '.concat(path, ':').concat(index));
                });
            }
            Utils.splitPath = splitPath;
            function absolutePath(path) {
                return ''.concat(fso.GetAbsolutePathName(path)).concat(/\\$/.test(path) ? '\\' : '');
            }
            function relativePath(path, base) {
                var absolute = absolutePath(path);
                var pathSplitted = splitPath(absolute);
                var aa = absolutePath(''.concat(base || '.', '\\'));
                var baseSplitted = splitPath(aa);
                var limit = Math.min(pathSplitted.length, baseSplitted.length);
                var matchedLength = 0;
                while (matchedLength < limit &&
                    pathSplitted[matchedLength].toLowerCase() === baseSplitted[matchedLength].toLowerCase()) {
                    ++matchedLength;
                }
                if (!matchedLength) {
                    return pathSplitted.join('');
                }
                if (matchedLength === pathSplitted.length && matchedLength === baseSplitted.length) {
                    return '.';
                }
                return ((baseSplitted.length > matchedLength ? '..\\'.repeat(baseSplitted.length - matchedLength) : '') +
                    pathSplitted.slice(matchedLength).join(''));
            }
            Utils.relativePath = relativePath;
            function commonPath() {
                var paths = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    paths[_i] = arguments[_i];
                }
                if (!paths.length) {
                    return '';
                }
                if (paths.length === 1) {
                    return paths[0];
                }
                var common = paths
                    .map(function (path) { return fso.GetAbsolutePathName(path); })
                    .map(function (path) { return splitPath(path); })
                    .reduce(function (result, path) {
                    var limit = Math.max(result.length, path.length);
                    for (var i = 0; i < limit; ++i) {
                        if (result[i] === path[i]) {
                            continue;
                        }
                        if (i === result.length) {
                            return result;
                        }
                        if (i === path.length) {
                            return path;
                        }
                        return result.slice(0, i);
                    }
                    return result;
                });
                if (common.length === 0) {
                    return undefined;
                }
                if (common.length === 1) {
                    return common[0];
                }
                return common.reduce(function (built, path) { return fso.BuildPath(built, path); });
            }
            Utils.commonPath = commonPath;
            function recursiveFolders(folder) {
                var _a, _b, f, e_11_1;
                var e_11, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, folder];
                        case 1:
                            _d.sent();
                            _d.label = 2;
                        case 2:
                            _d.trys.push([2, 7, 8, 9]);
                            _a = __values(subFolders(folder)), _b = _a.next();
                            _d.label = 3;
                        case 3:
                            if (!!_b.done) return [3 /*break*/, 6];
                            f = _b.value;
                            return [5 /*yield**/, __values(recursiveFolders(f))];
                        case 4:
                            _d.sent();
                            _d.label = 5;
                        case 5:
                            _b = _a.next();
                            return [3 /*break*/, 3];
                        case 6: return [3 /*break*/, 9];
                        case 7:
                            e_11_1 = _d.sent();
                            e_11 = { error: e_11_1 };
                            return [3 /*break*/, 9];
                        case 8:
                            try {
                                if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                            }
                            finally { if (e_11) throw e_11.error; }
                            return [7 /*endfinally*/];
                        case 9: return [2 /*return*/];
                    }
                });
            }
            Utils.recursiveFolders = recursiveFolders;
            function recursiveFiles(folder) {
                var _a, _b, f, e_12_1;
                var e_12, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            _d.trys.push([0, 5, 6, 7]);
                            _a = __values(recursiveFolders(folder)), _b = _a.next();
                            _d.label = 1;
                        case 1:
                            if (!!_b.done) return [3 /*break*/, 4];
                            f = _b.value;
                            return [5 /*yield**/, __values(files(f))];
                        case 2:
                            _d.sent();
                            _d.label = 3;
                        case 3:
                            _b = _a.next();
                            return [3 /*break*/, 1];
                        case 4: return [3 /*break*/, 7];
                        case 5:
                            e_12_1 = _d.sent();
                            e_12 = { error: e_12_1 };
                            return [3 /*break*/, 7];
                        case 6:
                            try {
                                if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                            }
                            finally { if (e_12) throw e_12.error; }
                            return [7 /*endfinally*/];
                        case 7: return [2 /*return*/];
                    }
                });
            }
            Utils.recursiveFiles = recursiveFiles;
            function recursiveFolderAndFiles(folder) {
                var _a, _b, f, e_13_1;
                var e_13, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            _d.trys.push([0, 6, 7, 8]);
                            _a = __values(recursiveFolders(folder)), _b = _a.next();
                            _d.label = 1;
                        case 1:
                            if (!!_b.done) return [3 /*break*/, 5];
                            f = _b.value;
                            return [4 /*yield*/, f];
                        case 2:
                            _d.sent();
                            return [5 /*yield**/, __values(files(f))];
                        case 3:
                            _d.sent();
                            _d.label = 4;
                        case 4:
                            _b = _a.next();
                            return [3 /*break*/, 1];
                        case 5: return [3 /*break*/, 8];
                        case 6:
                            e_13_1 = _d.sent();
                            e_13 = { error: e_13_1 };
                            return [3 /*break*/, 8];
                        case 7:
                            try {
                                if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                            }
                            finally { if (e_13) throw e_13.error; }
                            return [7 /*endfinally*/];
                        case 8: return [2 /*return*/];
                    }
                });
            }
            Utils.recursiveFolderAndFiles = recursiveFolderAndFiles;
            function wildcardToRegExp(pattern) {
                if (!pattern) {
                    return undefined;
                }
                if (pattern.includes('\\')) {
                    throw new Error('Unsupported wildcard: '.concat(pattern));
                }
                var depth = 0;
                var regex = '^' +
                    pattern.replace(/[\^$()\[\]{}+.*?,]/g, function (ch) {
                        switch (ch) {
                            case '*':
                                return '.*';
                            case '?':
                                return '.';
                            case '{':
                                ++depth;
                                return '(?:';
                            case '}':
                                if (depth <= 0) {
                                    throw new Error('Unmatched `}`');
                                }
                                --depth;
                                return ')';
                            case ',':
                                return depth > 0 ? '|' : ',';
                            default:
                                return '\\' + ch;
                        }
                    }) + '$';
                if (depth > 0) {
                    throw new Error('Unmatched `{`');
                }
                return new RegExp(regex, 'i');
            }
            Utils.wildcardToRegExp = wildcardToRegExp;
            /**
             * 指定されたパターンにマッチする全てのファイル/フォルダを順次返すイテレータを返す。
             * @param pattern 検索するファイル/フォルダ名のパターン。`**`はそれ以下の全てのパス、`?`は名前に使用される全ての1文字、`*`は0以上の名前に使用される全ての文字にマッチする。
             * @param basedir 検索を開始するディレクトリへのパス。省略時にはカレントディレクトリ。
             */
            function wildcard(pattern, basedir) {
                basedir = fso.GetAbsolutePathName(basedir || '.');
                var fullpath = isAbsolute(pattern) ? pattern : fso.BuildPath(basedir, pattern);
                if (!/[*?{]/.test(fullpath)) {
                    if (fso.FolderExists(fullpath)) {
                        return Iterables.of(fso.GetFolder(fullpath));
                    }
                    if (fso.FileExists(fullpath)) {
                        return Iterables.of(fso.GetFile(fullpath));
                    }
                    return Iterables.of();
                }
                var match = fullpath.match(/^(?:[A-Z]:|\\\\[^\\]+\\+[^\\]+)?(?:\\+[^*?{]+)*\\+/i);
                if (!match) {
                    throw new Error('');
                }
                var root = match[0];
                if (!fso.FolderExists(root)) {
                    throw new Error('The folder not found: '.concat(root));
                }
                var folder = fso.GetFolder(root);
                var pathes = fullpath
                    .slice(root.length)
                    .split(/\\+/)
                    .map(function (pathAtom, index, array) {
                    if (pathAtom === '') {
                        return function (f) {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, f];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        };
                    }
                    var last = index + 1 === array.length;
                    if (pathAtom === '**') {
                        return last ? recursiveFolderAndFiles : recursiveFolders;
                    }
                    if (/[*?{]/.test(pathAtom)) {
                        var atomPattern_1 = wildcardToRegExp(pathAtom);
                        return function (ff) {
                            var _a, _b, f, e_14_1, _c, _d, f, e_15_1;
                            var e_14, _e, e_15, _f;
                            return __generator(this, function (_g) {
                                switch (_g.label) {
                                    case 0:
                                        _g.trys.push([0, 5, 6, 7]);
                                        _a = __values(subFolders(ff)), _b = _a.next();
                                        _g.label = 1;
                                    case 1:
                                        if (!!_b.done) return [3 /*break*/, 4];
                                        f = _b.value;
                                        if (!(atomPattern_1 && atomPattern_1.test(f.Name))) return [3 /*break*/, 3];
                                        return [4 /*yield*/, f];
                                    case 2:
                                        _g.sent();
                                        _g.label = 3;
                                    case 3:
                                        _b = _a.next();
                                        return [3 /*break*/, 1];
                                    case 4: return [3 /*break*/, 7];
                                    case 5:
                                        e_14_1 = _g.sent();
                                        e_14 = { error: e_14_1 };
                                        return [3 /*break*/, 7];
                                    case 6:
                                        try {
                                            if (_b && !_b.done && (_e = _a["return"])) _e.call(_a);
                                        }
                                        finally { if (e_14) throw e_14.error; }
                                        return [7 /*endfinally*/];
                                    case 7:
                                        if (!last) return [3 /*break*/, 15];
                                        _g.label = 8;
                                    case 8:
                                        _g.trys.push([8, 13, 14, 15]);
                                        _c = __values(files(ff)), _d = _c.next();
                                        _g.label = 9;
                                    case 9:
                                        if (!!_d.done) return [3 /*break*/, 12];
                                        f = _d.value;
                                        if (!(atomPattern_1 && atomPattern_1.test(f.Name))) return [3 /*break*/, 11];
                                        return [4 /*yield*/, f];
                                    case 10:
                                        _g.sent();
                                        _g.label = 11;
                                    case 11:
                                        _d = _c.next();
                                        return [3 /*break*/, 9];
                                    case 12: return [3 /*break*/, 15];
                                    case 13:
                                        e_15_1 = _g.sent();
                                        e_15 = { error: e_15_1 };
                                        return [3 /*break*/, 15];
                                    case 14:
                                        try {
                                            if (_d && !_d.done && (_f = _c["return"])) _f.call(_c);
                                        }
                                        finally { if (e_15) throw e_15.error; }
                                        return [7 /*endfinally*/];
                                    case 15: return [2 /*return*/];
                                }
                            });
                        };
                    }
                    return function (ff) {
                        var lastpath;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    lastpath = fso.BuildPath(ff.Path, pathAtom);
                                    if (!fso.FolderExists(lastpath)) return [3 /*break*/, 2];
                                    return [4 /*yield*/, fso.GetFolder(lastpath)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                                case 2:
                                    if (!last) return [3 /*break*/, 4];
                                    if (!fso.FileExists(lastpath)) return [3 /*break*/, 4];
                                    return [4 /*yield*/, fso.GetFile(lastpath)];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/];
                                case 4: return [2 /*return*/];
                            }
                        });
                    };
                });
                return (function traverse(ff, index) {
                    var _a, _b, item, e_16_1;
                    var e_16, _c;
                    return __generator(this, function (_d) {
                        switch (_d.label) {
                            case 0:
                                if (!(index + 1 === pathes.length)) return [3 /*break*/, 2];
                                return [5 /*yield**/, __values(pathes[index](ff))];
                            case 1:
                                _d.sent();
                                return [2 /*return*/];
                            case 2:
                                _d.trys.push([2, 7, 8, 9]);
                                _a = __values(pathes[index](ff)), _b = _a.next();
                                _d.label = 3;
                            case 3:
                                if (!!_b.done) return [3 /*break*/, 6];
                                item = _b.value;
                                if (!isFolder(item)) {
                                    return [3 /*break*/, 5];
                                }
                                return [5 /*yield**/, __values(traverse(item, index + 1))];
                            case 4:
                                _d.sent();
                                _d.label = 5;
                            case 5:
                                _b = _a.next();
                                return [3 /*break*/, 3];
                            case 6: return [3 /*break*/, 9];
                            case 7:
                                e_16_1 = _d.sent();
                                e_16 = { error: e_16_1 };
                                return [3 /*break*/, 9];
                            case 8:
                                try {
                                    if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
                                }
                                finally { if (e_16) throw e_16.error; }
                                return [7 /*endfinally*/];
                            case 9: return [2 /*return*/];
                        }
                    });
                })(folder, 0);
            }
            Utils.wildcard = wildcard;
            function ensureDirectory(dirpath) {
                if (!dirpath) {
                    return fso.GetFolder('.');
                }
                if (fso.FolderExists(dirpath)) {
                    return fso.GetFolder(dirpath);
                }
                if (fso.FileExists(dirpath)) {
                    throw new Error('ファイルが存在しています。: '.concat(dirpath));
                }
                ensureDirectory(fso.GetParentFolderName(dirpath));
                return fso.CreateFolder(dirpath);
            }
            Utils.ensureDirectory = ensureDirectory;
            function resolve() {
                var e_17, _a;
                var paths = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    paths[_i] = arguments[_i];
                }
                var current = fso.GetAbsolutePathName('.');
                try {
                    for (var paths_1 = __values(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {
                        var path = paths_1_1.value;
                        if (isAbsolute(path)) {
                            // 絶対パスの場合は置き換え
                            current = path;
                        }
                        else {
                            // 相対パスの場合は連結
                            current = fso.BuildPath(current, path);
                        }
                    }
                }
                catch (e_17_1) { e_17 = { error: e_17_1 }; }
                finally {
                    try {
                        if (paths_1_1 && !paths_1_1.done && (_a = paths_1["return"])) _a.call(paths_1);
                    }
                    finally { if (e_17) throw e_17.error; }
                }
                return current;
            }
            Utils.resolve = resolve;
            function isAbsolute(path) {
                return /^(?:[A-Z]:|\\\\[^\\\/"<>|*?:]+\\[^\\\/"<>|*?:]+)?\\/i.test(path);
            }
            Utils.isAbsolute = isAbsolute;
        })(Utils = FileSystemObject.Utils || (FileSystemObject.Utils = {}));
    })(FileSystemObject = Scripting.FileSystemObject || (Scripting.FileSystemObject = {}));
})(Scripting || (Scripting = {}));
/// <reference types="wscript-util" />
/// <reference types="iterables" />
/// <reference types="filesystemobject-util" />
/// <reference types="windows-installer" />
/// <reference types="dom3" />
/// <reference types="activex-shell" />
var filever;
(function (filever) {
    var fsoU = Scripting.FileSystemObject.Utils;
    /**
     * ファイルのバージョンを取得する。
     *
     * 具体的に取得するバージョンは以下のとおり。
     *
     * - msiはPropertyテーブルのProductVersion
     * - mspはPatch情報XMLのUpdatedVersion
     * - exeやdllなどバージョンリソースのあるものはそのバージョンリソース
     * - バージョンリソースの無いものは`-`
     *
     * @param filepath バージョンを取得するファイルへのパス。
     * @return \{{{string}}\} ファイルのバージョン。
     */
    function getFileVersion(filepath) {
        var _a;
        if (/\.msi$/i.test(filepath)) {
            var db = installer.OpenDatabase(filepath, 0);
            var view = db.OpenView("SELECT Value FROM Property WHERE Property = 'ProductVersion'");
            try {
                view.Execute();
                var record = view.Fetch();
                return (_a = record === null || record === void 0 ? void 0 : record.StringData(1)) !== null && _a !== void 0 ? _a : '-';
            }
            finally {
                view.Close();
            }
        }
        if (/\.msp$/i.test(filepath)) {
            var xml = installer.ExtractPatchXMLData(filepath);
            var doc = WScript.CreateObject('MSXML2.DOMDocument.6.0');
            doc.async = false;
            doc.setProperty('SelectionNamespaces', "xmlns:patch='http://www.microsoft.com/msi/patch_applicability.xsd'");
            if (!doc.loadXML(xml)) {
                throw new Error(''.concat(filepath, ':\n    errorCode: ').concat(doc.parseError.errorCode, '\n    reason: ').concat(doc.parseError.reason, '\n    line: ').concat(doc.parseError.line, '\n    linepos: ').concat(doc.parseError.linepos, '\n    filepos: ').concat(doc.parseError.filepos, '\n    srcText: ').concat(doc.parseError.srcText, '\n    url: ').concat(doc.parseError.url));
            }
            return doc.selectSingleNode('/patch:MsiPatch/patch:TargetProduct/patch:UpdatedVersion').text;
        }
        return installer.FileVersion(filepath) || '-';
    }
    /** ファイル内容からのハッシュを16進文字列で返す。 */
    function FileHash(filepath) {
        var e_18, _a;
        var record = installer.FileHash(filepath, 0);
        var hexhash = '';
        for (var i = 1; i <= 4; ++i) {
            var hash = record.IntegerData(i);
            try {
                for (var _b = (e_18 = void 0, __values([(hash >> 16) & 0xffff, hash & 0xffff])), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var h = _c.value;
                    hexhash += h.toString(16).padStart(4, '0');
                }
            }
            catch (e_18_1) { e_18 = { error: e_18_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
                }
                finally { if (e_18) throw e_18.error; }
            }
        }
        return hexhash;
    }
    /** 電子署名済みであれば署名者を返す。 */
    function checkSignature(file) {
        // 署名チェックツールの実行
        var process = wshShell.Exec('"'.concat(signtool(), '" verify /pa /v "').concat(file.Path, '"'));
        // 標準出力および標準エラー出力から署名情報を取得
        var signer = '';
        var inSigningCertificateChain = false;
        var timestamped = false;
        while (!process.StdOut.AtEndOfStream || !process.StdErr.AtEndOfStream) {
            var line = (process.StdOut.AtEndOfStream
                ? process.StdErr.ReadLine()
                : process.StdOut.ReadLine()).trim();
            // 署名
            if (line.startsWith('Signing Certificate Chain:')) {
                inSigningCertificateChain = true;
                continue;
            }
            // 時刻署名
            if (line.startsWith('Timestamp Verified by:')) {
                inSigningCertificateChain = false;
                continue;
            }
            // 署名確認成功
            if (line.startsWith('Successfully verified: ')) {
                inSigningCertificateChain = false;
                break;
            }
            // 時刻署名の確認
            if (line.startsWith('The signature is timestamped: ')) {
                timestamped = true;
                continue;
            }
            // 拡張子の形式になっていないので無視
            if (line === 'SignTool Error: This file format cannot be verified because it is not') {
                signer = '署名対象外';
                break;
            }
            // 署名していない
            if (line === 'SignTool Error: No signature found.') {
                signer = '署名していない';
                break;
            }
            // 署名エラー
            if (line.startsWith('SignTool Error: ')) {
                signer = '!!!!署名エラー('.concat(line.substr(16), ')!!!!');
                break;
            }
            // 署名済み
            if (inSigningCertificateChain && line.startsWith('Issued to: ')) {
                signer = line.substr(11);
                continue;
            }
        }
        // サインツールのエラー
        if (!signer) {
            signer = '!!!!sintool error!!!!';
        }
        // 時刻署名しているかどうかもチェック
        if (!timestamped) {
            signer = '!!!!時刻署名なし!!!!('.concat(signer, ')');
        }
        return signer;
    }
    // コンテンツの作成日時を返す
    function GetContentCreationDate(file) {
        if (fso.GetExtensionName(file.Name).toLowerCase() === 'msp') {
            // MSPだけはMsiPatchMetadataのCreationTimeUTCから取得
            var database = installer.OpenDatabase(file.Path, 32 /* WindowsInstaller.msiOpenDatabaseMode.msiOpenDatabaseModePatchFile */);
            var view = database.OpenView("SELECT Value FROM MsiPatchMetadata WHERE Property = 'CreationTimeUTC'");
            try {
                view.Execute();
                var record = view.Fetch();
                if (!record) {
                    return;
                }
                var match = record
                    .StringData(1)
                    .match(/^(\d+)-(\d+)-(\d+)\s+(\d+:\d+)$/);
                if (!match) {
                    return;
                }
                return new Date(''.concat(match[1], '/').concat(match[2], '/').concat(match[3], ' ').concat(match[4])).toLocaleString();
            }
            finally {
                view.Close();
            }
        }
        var folder = shellapp.NameSpace(file.ParentFolder.Path);
        if (!folder) {
            return;
        }
        var folderItem = folder.ParseName(file.Name);
        if (!folderItem) {
            return;
        }
        var timestamp = folderItem.ExtendedProperty('{F29F85E0-4FF9-1068-AB91-08002B27B3D9} 12');
        if (timestamp !== undefined) {
            return new Date(timestamp).toLocaleString(); // コンテンツの作成日時
        }
    }
    // ADODB.Streamが返すバイナリストリームをJavaScriptで扱えるように変換するため、dataType: 'bin.hex'を使う
    var el = WScript.CreateObject('MSXML2.DOMDocument.6.0').createElement('t');
    // ADODB.Streamからバイナリデータを読み込む
    function readStream(stream, pos, length, bigEndian) {
        if (pos > stream.Size) {
            return null;
        }
        stream.Position = pos;
        el.dataType = 'bin.hex';
        el.nodeTypedValue = stream.Read(length);
        return parseInt(bigEndian
            ? el.text
            : el.text
                .split(/(?=(?:[0-9a-f]{2})+$)/)
                .reverse()
                .join(''), 16);
    }
    // ビルドした日時を返す
    function GetBuildDate(file) {
        if (!fsoU.isFile(file)) {
            return;
        }
        // MSI/MSPは作成日時
        switch (fso.GetExtensionName(file.Name).toLowerCase()) {
            case 'msi':
            case 'msp':
                return GetContentCreationDate(file);
        }
        var STREAM = WScript.CreateObject('ADODB.Stream');
        STREAM.Mode = 3 /* ADODB.ConnectModeEnum.adModeReadWrite */;
        STREAM.Type = 1 /* ADODB.StreamTypeEnum.adTypeBinary */;
        STREAM.Open();
        try {
            STREAM.LoadFromFile(file.Path);
            if (readStream(STREAM, 0, 2, true) !== 0x4d5a /* MZ */) {
                return;
            }
            var pePos = readStream(STREAM, 0x3c, 4);
            if (pePos === null) {
                return;
            }
            if (readStream(STREAM, pePos, 2, true) !== 0x5045 /* PE */) {
                return;
            }
            var timestamp = readStream(STREAM, pePos + 8, 4);
            if (timestamp === null) {
                return;
            }
            // timestampは1970年1月1日午前0時0分0秒からの経過秒数なのでミリ秒に変換
            return new Date(timestamp * 1000).toLocaleString();
        }
        finally {
            STREAM.Close();
        }
    }
    /**
     * ワイルドカード、相対パスの基準ディレクトリ。
     * コマンドラインオプション/basedirで変更可能。
     */
    var basedir = WScriptUtil.Arguments.Named(['BaseDir', 'Base', 'B']) || '.';
    /**
     * 出力するファイル情報のフォーマット。
     * 省略時は`$r\t$v`(相対パスとバージョン)
     */
    var format = WScriptUtil.Arguments.Named(['Format', 'F']) || '$r\t$v';
    /**
     * 追加書き込みするかどうか。省略時には新規書き込み。
     */
    var appendMode = WScriptUtil.Arguments.Switch(['Append', 'A']);
    /**
     * 出力先のファイル。省略時には標準出力を使う。
     */
    var output = WScriptUtil.Arguments.Named({
        key: ['Output', 'Out', 'O'],
        conv: function (outputPath) {
            if (!outputPath) {
                return WScript.StdOut;
            }
            var mode = appendMode
                ? 8 /* Scripting.IOMode.ForAppending */
                : 2 /* Scripting.IOMode.ForWriting */;
            return fso.OpenTextFile(outputPath, mode, true, 0 /* Scripting.Tristate.TristateFalse */);
        }
    });
    /**
     * 使い方を表示するかどうか。
     */
    var showHelp = WScriptUtil.Arguments.Switch(['Help', 'H', '?']);
    /** 無視するファイル・ディレクトリを判定する。 FileOnlyが指定されていればファイル以外を無視、DirectoryOnlyが指定されていればディレクトリ以外を無視。 */
    var ignored = WScriptUtil.Arguments.Switch('FileOnly')
        ? function (file) { return !fsoU.isFile(file); }
        : WScriptUtil.Arguments.Switch('DirectoryOnly')
            ? function (file) { return !fsoU.isFolder(file); }
            : function () { return false; };
    // コマンドラインオプションでsigntoolの指定があればそちらを優先する。
    var signtoolCache = WScriptUtil.Arguments.Named('SignTool');
    // 利用されるまでパス解決を行わないようにする
    function signtool() {
        var e_19, _a;
        // コマンドラインオプションでの指定があった場合はそちらを、既にコマンドを実行した場合は前回の結果を使用する。
        if (signtoolCache !== undefined) {
            return signtoolCache;
        }
        if (fso.FileExists('signtool.exe')) {
            // カレントディレクトリにあれば'signtool'だけでいい
            return (signtoolCache = 'signtool');
        }
        var onScriptPath = fso.BuildPath(fso.GetParentFolderName(WScript.ScriptFullName), 'signtool.exe');
        if (fso.FileExists(onScriptPath)) {
            // スクリプトと同じディレクトリにあればそれを使う
            return (signtoolCache = onScriptPath);
        }
        try {
            for (var _b = __values(wshShell.Environment.Item('PATH').split(/;/)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var path = _c.value;
                if (fso.FileExists(fso.BuildPath(path.replace(/^"(.*)"$/, '$1'), 'signtool.exe'))) {
                    // Pathが通っていれば'signtool'だけでいい
                    return (signtoolCache = 'signtool');
                }
            }
        }
        catch (e_19_1) { e_19 = { error: e_19_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
            }
            finally { if (e_19) throw e_19.error; }
        }
        // signtoolにパスが通っていなければレジストリからsigntoolのフルパスを取得
        try {
            var sdk = wshShell.RegRead('HKLM\\SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows\\CurrentInstallFolder');
            if (typeof sdk === 'string') {
                return (signtoolCache = fsoU.resolve(sdk, 'bin', 'signtool.exe'));
            }
        }
        catch (ex) {
            // レジストリからも取得に失敗したら例外
            throw new Error('signtoolが見つかりません。: '.concat(ex));
        }
    }
    /**
     * タイムスタンプを表示しないファイル名のパターン
     */
    var noTimestamp = WScriptUtil.Arguments.Named('NoTimeStamp', function (param) { return (param && fsoU.wildcardToRegExp(param)) || undefined; });
    var shellappdesktopCache;
    function ShellappDesktop() {
        if (shellappdesktopCache !== undefined) {
            return shellappdesktopCache;
        }
        shellappdesktopCache = shellapp.NameSpace(0 /* Shell32.ShellSpecialFolderConstants.ssfDESKTOP */);
        return shellappdesktopCache || (shellappdesktopCache = null);
    }
    function GetExtendedProperty(file, propertyName) {
        var desktop = ShellappDesktop();
        if (!desktop) {
            return '-';
        }
        var item = desktop.ParseName(file.Path);
        if (!item) {
            return '-';
        }
        var c = item.ExtendedProperty(propertyName);
        if (!c) {
            return '-';
        }
        return c;
    }
    /**
     * 表示されるファイルの情報
     */
    var COLUMNS = {
        // ビルド日時。ビルド日時の取得できないファイル、ディレクトリの場合は`-`
        build: function (file) { return GetBuildDate(file) || '-'; },
        // バージョンリソースの
        company: function (file) {
            return (fsoU.isFile(file) && GetExtendedProperty(file, 'System.Company')) || '-';
        },
        // バージョンリソースの著作権欄
        copyright: function (file) {
            return (fsoU.isFile(file) && GetExtendedProperty(file, 'System.Copyright')) || '-';
        },
        // ファイルの存在するディレクトリ(ディレクトリの場合はそのディレクトリ自身)のフルパス。
        directory: function (file) { return (fsoU.isFolder(file) ? file : file.ParentFolder).Path; },
        // フルパス。
        fullpath: function (file) { return file.Path; },
        // 16進文字列で表記したファイルハッシュ。ディレクトリの場合は`-`
        hash: function (file) { return (fsoU.isFolder(file) ? '-' : FileHash(file.Path)); },
        // ファイルサイズ(桁区切り無し)、ディレクトリの場合は`-`
        length: function (file) { return (fsoU.isFolder(file) ? '-' : '' + file.Size); },
        // ファイル名、ディレクトリの場合は`-`。
        name: function (file) { return (fsoU.isFolder(file) ? '-' : file.Name); },
        // 相対パス。基準となるディレクトリは/BaseDirで指定する。
        relative: function (file) { return fsoU.relativePath(file.Path, basedir); },
        // directoryの相対パス版。基準となるディレクトリは/BaseDirで指定する。
        reldir: function (file) {
            return fsoU.relativePath((fsoU.isFolder(file) ? file : file.ParentFolder).Path, basedir);
        },
        // 電子署名済みの場合は署名者。署名に不備があれば不備の内容。ディレクトリの場合は`-`
        sign: function (file) { return (fsoU.isFile(file) ? checkSignature(file) : '-'); },
        // ファイルサイズ(3桁区切り)、ディレクトリの場合は`-`
        size: function (file) {
            return fsoU.isFolder(file)
                ? '-' : ('' + file.Size).replace(/\d(?=(?:\d{3})+$)/g, '$&,');
        },
        // タイムスタンプ
        timestamp: function (file) {
            return (noTimestamp && noTimestamp.test(file.Name) && '-') ||
                new Date(file.DateLastModified).toLocaleString();
        },
        // ファイルのバージョン。ディレクトリ、バージョンのないファイルは`-`
        version: function (file) { return (fsoU.isFolder(file) ? '-' : getFileVersion(file.Path)); }
    };
    // 各情報のエイリアス
    COLUMNS.n = COLUMNS.name;
    COLUMNS.d = COLUMNS.dir = COLUMNS.directory;
    COLUMNS.s = COLUMNS.size;
    COLUMNS.l = COLUMNS.len = COLUMNS.length;
    COLUMNS.v = COLUMNS.ver = COLUMNS.version;
    COLUMNS.f = COLUMNS.full = COLUMNS.fullpath;
    COLUMNS.r = COLUMNS.rel = COLUMNS.relative;
    COLUMNS.t = COLUMNS.time = COLUMNS.timestamp;
    COLUMNS.h = COLUMNS.hash;
    COLUMNS.g = COLUMNS.sign;
    COLUMNS.b = COLUMNS.build;
    COLUMNS.rd = COLUMNS.reldir;
    COLUMNS.cp = COLUMNS.company;
    COLUMNS.cr = COLUMNS.copyright;
    function column(name, file) {
        if (!name) {
            return;
        }
        name = name.toLowerCase();
        if (!(name in COLUMNS)) {
            return;
        }
        return COLUMNS[name](file);
    }
    function main() {
        var e_20, _a, e_21, _b;
        if (showHelp) {
            WScript.StdOut
                .Write("filevar.wsf: List information such as version and name of files and directories.\n\nUSAGE:\n  cscript //nologo filever.wsf /Help\n  cscript //nologo filever.wsf [/BaseDir:\"base\\directory\"] [/Format:\"Format for output\"] [/Output:\"output file\"] [path of files and directories...]\n\n/Help\n      Show this help.\n      Alias: /H /?\n/BaseDir:\"base\\directory\"\n      Specify the base directory of the specified path pattern.\n      If omitted, it is assumed that the current directory is specified.\n      Alias: /Base /B\n/Format:\"Format for output\"\n      Specify the format used for output of file and directory information.\n      If omitted, it is assumed that the '$r\\t$v' is specified\n      Alias: /F\n\n      $name\n        The name of the file or the directory.\n        Alias: $n\n      $directory\n        The path of the parent directory if it is a file, or its own path if it is a directory.\n        Alias: $dir $d\n      $size\n        The three-digit delimited file size, or '-' if it is a directory.\n        Alias: $s\n      $length\n        The file size(no delimited), or '-' if it is a directory.\n        Alias: $len $l\n      $version\n        The version of the file, or '-' if it is a file without a version or it is a directory.\n        Alias: $ver $v\n      $fullpath\n        The full path of the file or the directory.\n        Alias: $full $f\n      $relative\n        The relative path of the file or the directory.\n        Alias: $rel $r\n      $reldir\n        The relative path of the parent directory if it is a file, or its own relative path if it is a directory.\n        Alias: $rd\n      $timestamp\n        The full path of the file or the directory.\n        Alias: $time $t\n      $hash\n        The hash of the file, or '-' if it is a directory.\n        Alias: $h\n      $build\n        The date to build the content.\n        Alias: $b\n      $sign\n        The signer if the file is digitally signed, the error message if the signature it is incomplete. '-' if it is a directory.\n        Alias: $g\n      $company\n        The company in the file version resource, or '-' if it is a directory, or with out the version resource.\n        Alias: $cp\n      $copyright\n        The copyright in the file version resource, or '-' if it is a directory, or with out the version resource.\n        Alias: $cr\n/Output:\"output file\"\n      The file to output into.\n      If omitted, output into standard output.\n      Alias: /Out /O\n/Append\n      Specify it with /Output, then append output to file.\n/fileonly\n      Show information of files only.\n/directoryonly\n      Show information of directories only.\n      This parameter is ignored if `/fileonly` specified.\n/noTimestamp:filename-pattern\n      Specify a pattern of file names that do not show timestamps.\n      If omitted, show timestamps of all files.\n/signtool:signtool_path\n      Specify the path to 'signtool.exe'.\n      If omitted, find signtool.exe from the current directory,\n      this script directory, and Windows SDK directory\n\npath of files and directories...\n      Files and directories for listing information. Wild cards can be used.\n      Example:\n      *.dll\n        DLL files in the current directory.\n      aaa?.dll\n        Dll files with only one letter after aaa.\n      *.{exe;dll;ocx}\n        EXE, DLL, OCX files in the current directory.\n      aaa\\**\\*.{exe;dll;ocx}\n        All EXE, DLL, OCX files under aaa directory.\n");
            return;
        }
        var args = __spreadArray([], __read(Iterables.from(WScript.Arguments.Unnamed)), false);
        if (args.length === 0) {
            args = ['**'];
        }
        try {
            // 各ファイル指定をワイルドカードとして展開
            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                var arg = args_1_1.value;
                var _loop_1 = function (file) {
                    if (ignored(file)) {
                        return 'continue';
                    }
                    // 各ファイルの情報をフォーマットに従って出力
                    output.WriteLine(format.replace(/\$(?:\{(\w+)\}|(\w+))|\\(?:x([0-9A-Fa-f]{2})|(.))/g, function (whole, name1, name2, hex, ch) {
                        var value = column(name1 || name2, file);
                        if (typeof value === 'string') {
                            return value;
                        }
                        if (hex) {
                            return String.fromCharCode(parseInt(hex, 16));
                        }
                        if (ch) {
                            switch (ch) {
                                case 't':
                                    return '\t';
                                case 'r':
                                    return '\r';
                                case 'n':
                                    return '\n';
                            }
                            return ch;
                        }
                        return whole;
                    }));
                };
                try {
                    for (var _c = (e_21 = void 0, __values(fsoU.wildcard(arg, basedir))), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var file = _d.value;
                        _loop_1(file);
                    }
                }
                catch (e_21_1) { e_21 = { error: e_21_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c["return"])) _b.call(_c);
                    }
                    finally { if (e_21) throw e_21.error; }
                }
            }
        }
        catch (e_20_1) { e_20 = { error: e_20_1 }; }
        finally {
            try {
                if (args_1_1 && !args_1_1.done && (_a = args_1["return"])) _a.call(args_1);
            }
            finally { if (e_20) throw e_20.error; }
        }
    }
    filever.main = main;
})(filever || (filever = {}));
filever.main();


})();
]]></script>
</job>